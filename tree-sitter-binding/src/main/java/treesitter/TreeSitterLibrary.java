package treesitter;

import com.sun.jna.*;
import com.sun.jna.ptr.IntByReference;
import com.sun.jna.ptr.PointerByReference;

import java.nio.IntBuffer;



/**
 * JNA Wrapper for library <b>treesitter</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> , <a href="http://rococoa.dev.java.net/">Rococoa</a>, or <a href="http://jna.dev.java.net/">JNA</a>.
 */
public interface TreeSitterLibrary extends Library {
	public static final TreeSitterLibrary INSTANCE = PlatformUtils.loadLibrary();


	/**
	 * <i>native declaration : line 47</i><br>
	 * enum values
	 */
	public static interface TSInputEncoding {
		/** <i>native declaration : line 48</i> */
		public static final int TSInputEncodingUTF8 = 0;
		/** <i>native declaration : line 49</i> */
		public static final int TSInputEncodingUTF16 = 1;
	};
	/**
	 * <i>native declaration : line 52</i><br>
	 * enum values
	 */
	public static interface TSSymbolType {
		/** <i>native declaration : line 53</i> */
		public static final int TSSymbolTypeRegular = 0;
		/** <i>native declaration : line 54</i> */
		public static final int TSSymbolTypeAnonymous = 1;
		/** <i>native declaration : line 55</i> */
		public static final int TSSymbolTypeAuxiliary = 2;
	};
	/**
	 * <i>native declaration : line 76</i><br>
	 * enum values
	 */
	public static interface TSLogType {
		/** <i>native declaration : line 77</i> */
		public static final int TSLogTypeParse = 0;
		/** <i>native declaration : line 78</i> */
		public static final int TSLogTypeLex = 1;
	};
	/**
	 * <i>native declaration : line 112</i><br>
	 * enum values
	 */
	public static interface TSQuantifier {
		/**
		 * must match the array initialization value<br>
		 * <i>native declaration : line 113</i>
		 */
		public static final int TSQuantifierZero = 0;
		/** <i>native declaration : line 114</i> */
		public static final int TSQuantifierZeroOrOne = 1;
		/** <i>native declaration : line 115</i> */
		public static final int TSQuantifierZeroOrMore = 2;
		/** <i>native declaration : line 116</i> */
		public static final int TSQuantifierOne = 3;
		/** <i>native declaration : line 117</i> */
		public static final int TSQuantifierOneOrMore = 4;
	};
	/**
	 * <i>native declaration : line 127</i><br>
	 * enum values
	 */
	public static interface TSQueryPredicateStepType {
		/** <i>native declaration : line 128</i> */
		public static final int TSQueryPredicateStepTypeDone = 0;
		/** <i>native declaration : line 129</i> */
		public static final int TSQueryPredicateStepTypeCapture = 1;
		/** <i>native declaration : line 130</i> */
		public static final int TSQueryPredicateStepTypeString = 2;
	};
	/**
	 * <i>native declaration : line 138</i><br>
	 * enum values
	 */
	public static interface TSQueryError {
		/** <i>native declaration : line 139</i> */
		public static final int TSQueryErrorNone = 0;
		/** <i>native declaration : line 140</i> */
		public static final int TSQueryErrorSyntax = 1;
		/** <i>native declaration : line 141</i> */
		public static final int TSQueryErrorNodeType = 2;
		/** <i>native declaration : line 142</i> */
		public static final int TSQueryErrorField = 3;
		/** <i>native declaration : line 143</i> */
		public static final int TSQueryErrorCapture = 4;
		/** <i>native declaration : line 144</i> */
		public static final int TSQueryErrorStructure = 5;
		/** <i>native declaration : line 145</i> */
		public static final int TSQueryErrorLanguage = 6;
	};
	/** enum values */
	public static interface TSWasmErrorKind {
		/** <i>native declaration : line 1151</i> */
		public static final int TSWasmErrorKindNone = 0;
		/** <i>native declaration : line 1152</i> */
		public static final int TSWasmErrorKindParse = 1;
		/** <i>native declaration : line 1153</i> */
		public static final int TSWasmErrorKindCompile = 2;
		/** <i>native declaration : line 1154</i> */
		public static final int TSWasmErrorKindInstantiate = 3;
		/** <i>native declaration : line 1155</i> */
		public static final int TSWasmErrorKindAllocate = 4;
	};
	public static final int TREE_SITTER_LANGUAGE_VERSION = (int)14;
	public static final int TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION = (int)13;
	/** <i>native declaration : line 1230</i> */
	public interface ts_set_allocator_new_malloc_callback extends Callback {
		Pointer apply(NativeSize size_t1);
	};
	/** <i>native declaration : line 1231</i> */
	public interface ts_set_allocator_new_calloc_callback extends Callback {
		Pointer apply(NativeSize size_t1, NativeSize size_t2);
	};
	/** <i>native declaration : line 1232</i> */
	public interface ts_set_allocator_new_realloc_callback extends Callback {
		Pointer apply(Pointer voidPtr1, NativeSize size_t1);
	};
	/** <i>native declaration : line 1233</i> */
	public interface ts_set_allocator_new_free_callback extends Callback {
		void apply(Pointer voidPtr1);
	};
	/**
	 * Create a new parser.<br>
	 * Original signature : <code>TSParser* ts_parser_new()</code><br>
	 * <i>native declaration : line 155</i>
	 */
	TreeSitterLibrary.TSParser ts_parser_new();
	/**
	 * Delete the parser, freeing all of the memory that it used.<br>
	 * Original signature : <code>void ts_parser_delete(TSParser*)</code><br>
	 * <i>native declaration : line 160</i>
	 */
	void ts_parser_delete(TreeSitterLibrary.TSParser self);
	/**
	 * Get the parser's current language.<br>
	 * Original signature : <code>TSLanguage* ts_parser_language(const TSParser*)</code><br>
	 * <i>native declaration : line 165</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_language(treesitter.TreeSitterLibrary.TSParser[])} and {@link #ts_parser_language(treesitter.TreeSitterLibrary.TSParser)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSLanguage ts_parser_language(TreeSitterLibrary.TSParser self);
	/**
	 * Get the parser's current language.<br>
	 * Original signature : <code>TSLanguage* ts_parser_language(const TSParser*)</code><br>
	 * <i>native declaration : line 165</i>
	 */
	TreeSitterLibrary.TSLanguage ts_parser_language(TreeSitterLibrary.TSParser self[]);
	/**
	 * Set the language that the parser should use for parsing.<br>
	 * * Returns a boolean indicating whether or not the language was successfully<br>
	 * assigned. True means assignment succeeded. False means there was a version<br>
	 * mismatch: the language was generated with an incompatible version of the<br>
	 * Tree-sitter CLI. Check the language's version using [`ts_language_version`]<br>
	 * and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and<br>
	 * [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants.<br>
	 * Original signature : <code>bool ts_parser_set_language(TSParser*, const TSLanguage*)</code><br>
	 * <i>native declaration : line 177</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_set_language(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSLanguage[])} and {@link #ts_parser_set_language(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSLanguage)} instead
	 */
	@Deprecated
	byte ts_parser_set_language(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSLanguage language);
	/**
	 * Set the language that the parser should use for parsing.<br>
	 * * Returns a boolean indicating whether or not the language was successfully<br>
	 * assigned. True means assignment succeeded. False means there was a version<br>
	 * mismatch: the language was generated with an incompatible version of the<br>
	 * Tree-sitter CLI. Check the language's version using [`ts_language_version`]<br>
	 * and compare it to this library's [`TREE_SITTER_LANGUAGE_VERSION`] and<br>
	 * [`TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION`] constants.<br>
	 * Original signature : <code>bool ts_parser_set_language(TSParser*, const TSLanguage*)</code><br>
	 * <i>native declaration : line 177</i>
	 */
	byte ts_parser_set_language(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSLanguage language[]);
	/**
	 * Set the ranges of text that the parser should include when parsing.<br>
	 * * By default, the parser will always include entire documents. This function<br>
	 * allows you to parse only a *portion* of a document but still return a syntax<br>
	 * tree whose ranges match up with the document as a whole. You can also pass<br>
	 * multiple disjoint ranges.<br>
	 * * The second and third parameters specify the location and length of an array<br>
	 * of ranges. The parser does *not* take ownership of these ranges; it copies<br>
	 * the data, so it doesn't matter how these ranges are allocated.<br>
	 * * If `count` is zero, then the entire document will be parsed. Otherwise,<br>
	 * the given ranges must be ordered from earliest to latest in the document,<br>
	 * and they must not overlap. That is, the following must hold for all:<br>
	 * * `i < count - 1`: `ranges[i].end_byte <= ranges[i + 1].start_byte`<br>
	 * * If this requirement is not satisfied, the operation will fail, the ranges<br>
	 * will not be assigned, and this function will return `false`. On success,<br>
	 * this function returns `true`<br>
	 * Original signature : <code>bool ts_parser_set_included_ranges(TSParser*, const TSRange*, uint32_t)</code><br>
	 * <i>native declaration : line 201</i>
	 */
	byte ts_parser_set_included_ranges(TreeSitterLibrary.TSParser self, TSRange ranges, int count);
	/**
	 * Get the ranges of text that the parser will include when parsing.<br>
	 * * The returned pointer is owned by the parser. The caller should not free it<br>
	 * or write to it. The length of the array will be written to the given<br>
	 * `count` pointer.<br>
	 * Original signature : <code>TSRange* ts_parser_included_ranges(const TSParser*, uint32_t*)</code><br>
	 * <i>native declaration : line 214</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_included_ranges(treesitter.TreeSitterLibrary.TSParser[], java.nio.IntBuffer)} and {@link #ts_parser_included_ranges(treesitter.TreeSitterLibrary.TSParser, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	TSRange ts_parser_included_ranges(TreeSitterLibrary.TSParser self, IntByReference count);
	/**
	 * Get the ranges of text that the parser will include when parsing.<br>
	 * * The returned pointer is owned by the parser. The caller should not free it<br>
	 * or write to it. The length of the array will be written to the given<br>
	 * `count` pointer.<br>
	 * Original signature : <code>TSRange* ts_parser_included_ranges(const TSParser*, uint32_t*)</code><br>
	 * <i>native declaration : line 214</i>
	 */
	TSRange ts_parser_included_ranges(TreeSitterLibrary.TSParser self[], IntBuffer count);
	/**
	 * Use the parser to parse some source code and create a syntax tree.<br>
	 * * If you are parsing this document for the first time, pass `NULL` for the<br>
	 * `old_tree` parameter. Otherwise, if you have already parsed an earlier<br>
	 * version of this document and the document has since been edited, pass the<br>
	 * previous syntax tree so that the unchanged parts of it can be reused.<br>
	 * This will save time and memory. For this to work correctly, you must have<br>
	 * already edited the old syntax tree using the [`ts_tree_edit`] function in a<br>
	 * way that exactly matches the source code changes.<br>
	 * * The [`TSInput`] parameter lets you specify how to read the text. It has the<br>
	 * following three fields:<br>
	 * 1. [`read`]: A function to retrieve a chunk of text at a given byte offset<br>
	 *    and (row, column) position. The function should return a pointer to the<br>
	 *    text and write its length to the [`bytes_read`] pointer. The parser does<br>
	 *    not take ownership of this buffer; it just borrows it until it has<br>
	 *    finished reading it. The function should write a zero value to the<br>
	 *    [`bytes_read`] pointer to indicate the end of the document.<br>
	 * 2. [`payload`]: An arbitrary pointer that will be passed to each invocation<br>
	 *    of the [`read`] function.<br>
	 * 3. [`encoding`]: An indication of how the text is encoded. Either<br>
	 *    `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.<br>
	 * * This function returns a syntax tree on success, and `NULL` on failure. There<br>
	 * are three possible reasons for failure:<br>
	 * 1. The parser does not have a language assigned. Check for this using the<br>
	 * [`ts_parser_language`] function.<br>
	 * 2. Parsing was cancelled due to a timeout that was set by an earlier call to<br>
	 *    the [`ts_parser_set_timeout_micros`] function. You can resume parsing from<br>
	 *    where the parser left out by calling [`ts_parser_parse`] again with the<br>
	 *    same arguments. Or you can start parsing from scratch by first calling<br>
	 *    [`ts_parser_reset`].<br>
	 * 3. Parsing was cancelled using a cancellation flag that was set by an<br>
	 *    earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing<br>
	 *    from where the parser left out by calling [`ts_parser_parse`] again with<br>
	 *    the same arguments.<br>
	 * * [`read`]: TSInput::read<br>
	 * [`payload`]: TSInput::payload<br>
	 * [`encoding`]: TSInput::encoding<br>
	 * [`bytes_read`]: TSInput::read<br>
	 * Original signature : <code>TSTree* ts_parser_parse(TSParser*, const TSTree*, TSInput)</code><br>
	 * <i>native declaration : line 262</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_parse(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSTree[], treesitter.TSInput.ByValue)} and {@link #ts_parser_parse(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSTree, treesitter.TSInput.ByValue)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSTree ts_parser_parse(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSTree old_tree, treesitter.TSInput.ByValue input);
	/**
	 * Use the parser to parse some source code and create a syntax tree.<br>
	 * * If you are parsing this document for the first time, pass `NULL` for the<br>
	 * `old_tree` parameter. Otherwise, if you have already parsed an earlier<br>
	 * version of this document and the document has since been edited, pass the<br>
	 * previous syntax tree so that the unchanged parts of it can be reused.<br>
	 * This will save time and memory. For this to work correctly, you must have<br>
	 * already edited the old syntax tree using the [`ts_tree_edit`] function in a<br>
	 * way that exactly matches the source code changes.<br>
	 * * The [`TSInput`] parameter lets you specify how to read the text. It has the<br>
	 * following three fields:<br>
	 * 1. [`read`]: A function to retrieve a chunk of text at a given byte offset<br>
	 *    and (row, column) position. The function should return a pointer to the<br>
	 *    text and write its length to the [`bytes_read`] pointer. The parser does<br>
	 *    not take ownership of this buffer; it just borrows it until it has<br>
	 *    finished reading it. The function should write a zero value to the<br>
	 *    [`bytes_read`] pointer to indicate the end of the document.<br>
	 * 2. [`payload`]: An arbitrary pointer that will be passed to each invocation<br>
	 *    of the [`read`] function.<br>
	 * 3. [`encoding`]: An indication of how the text is encoded. Either<br>
	 *    `TSInputEncodingUTF8` or `TSInputEncodingUTF16`.<br>
	 * * This function returns a syntax tree on success, and `NULL` on failure. There<br>
	 * are three possible reasons for failure:<br>
	 * 1. The parser does not have a language assigned. Check for this using the<br>
	 * [`ts_parser_language`] function.<br>
	 * 2. Parsing was cancelled due to a timeout that was set by an earlier call to<br>
	 *    the [`ts_parser_set_timeout_micros`] function. You can resume parsing from<br>
	 *    where the parser left out by calling [`ts_parser_parse`] again with the<br>
	 *    same arguments. Or you can start parsing from scratch by first calling<br>
	 *    [`ts_parser_reset`].<br>
	 * 3. Parsing was cancelled using a cancellation flag that was set by an<br>
	 *    earlier call to [`ts_parser_set_cancellation_flag`]. You can resume parsing<br>
	 *    from where the parser left out by calling [`ts_parser_parse`] again with<br>
	 *    the same arguments.<br>
	 * * [`read`]: TSInput::read<br>
	 * [`payload`]: TSInput::payload<br>
	 * [`encoding`]: TSInput::encoding<br>
	 * [`bytes_read`]: TSInput::read<br>
	 * Original signature : <code>TSTree* ts_parser_parse(TSParser*, const TSTree*, TSInput)</code><br>
	 * <i>native declaration : line 262</i>
	 */
	TreeSitterLibrary.TSTree ts_parser_parse(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSTree old_tree[], treesitter.TSInput.ByValue input);
	/**
	 * Use the parser to parse some source code stored in one contiguous buffer.<br>
	 * The first two parameters are the same as in the [`ts_parser_parse`] function<br>
	 * above. The second two parameters indicate the location of the buffer and its<br>
	 * length in bytes.<br>
	 * Original signature : <code>TSTree* ts_parser_parse_string(TSParser*, const TSTree*, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 274</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_parse_string(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSTree[], java.lang.String, int)} and {@link #ts_parser_parse_string(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSTree, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSTree ts_parser_parse_string(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSTree old_tree, Pointer string, int length);
	/**
	 * Use the parser to parse some source code stored in one contiguous buffer.<br>
	 * The first two parameters are the same as in the [`ts_parser_parse`] function<br>
	 * above. The second two parameters indicate the location of the buffer and its<br>
	 * length in bytes.<br>
	 * Original signature : <code>TSTree* ts_parser_parse_string(TSParser*, const TSTree*, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 274</i>
	 */
	TreeSitterLibrary.TSTree ts_parser_parse_string(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSTree old_tree[], String string, int length);
	/**
	 * Use the parser to parse some source code stored in one contiguous buffer with<br>
	 * a given encoding. The first four parameters work the same as in the<br>
	 * [`ts_parser_parse_string`] method above. The final parameter indicates whether<br>
	 * the text is encoded as UTF8 or UTF16.<br>
	 * Original signature : <code>TSTree* ts_parser_parse_string_encoding(TSParser*, const TSTree*, const char*, uint32_t, TSInputEncoding)</code><br>
	 * <i>native declaration : line 287</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_parse_string_encoding(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSTree[], java.lang.String, int, int)} and {@link #ts_parser_parse_string_encoding(treesitter.TreeSitterLibrary.TSParser, treesitter.TreeSitterLibrary.TSTree, com.sun.jna.Pointer, int, int)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSTree ts_parser_parse_string_encoding(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSTree old_tree, Pointer string, int length, int encoding);
	/**
	 * Use the parser to parse some source code stored in one contiguous buffer with<br>
	 * a given encoding. The first four parameters work the same as in the<br>
	 * [`ts_parser_parse_string`] method above. The final parameter indicates whether<br>
	 * the text is encoded as UTF8 or UTF16.<br>
	 * Original signature : <code>TSTree* ts_parser_parse_string_encoding(TSParser*, const TSTree*, const char*, uint32_t, TSInputEncoding)</code><br>
	 * <i>native declaration : line 287</i>
	 */
	TreeSitterLibrary.TSTree ts_parser_parse_string_encoding(TreeSitterLibrary.TSParser self, TreeSitterLibrary.TSTree old_tree[], String string, int length, int encoding);
	/**
	 * Instruct the parser to start the next parse from the beginning.<br>
	 * * If the parser previously failed because of a timeout or a cancellation, then<br>
	 * by default, it will resume where it left off on the next call to<br>
	 * [`ts_parser_parse`] or other parsing functions. If you don't want to resume,<br>
	 * and instead intend to use this parser to parse some other document, you must<br>
	 * call [`ts_parser_reset`] first.<br>
	 * Original signature : <code>void ts_parser_reset(TSParser*)</code><br>
	 * <i>native declaration : line 304</i>
	 */
	void ts_parser_reset(TreeSitterLibrary.TSParser self);
	/**
	 * Set the maximum duration in microseconds that parsing should be allowed to<br>
	 * take before halting.<br>
	 * * If parsing takes longer than this, it will halt early, returning NULL.<br>
	 * See [`ts_parser_parse`] for more information.<br>
	 * Original signature : <code>void ts_parser_set_timeout_micros(TSParser*, uint64_t)</code><br>
	 * <i>native declaration : line 313</i>
	 */
	void ts_parser_set_timeout_micros(TreeSitterLibrary.TSParser self, long timeout_micros);
	/**
	 * Get the duration in microseconds that parsing is allowed to take.<br>
	 * Original signature : <code>uint64_t ts_parser_timeout_micros(const TSParser*)</code><br>
	 * <i>native declaration : line 318</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_timeout_micros(treesitter.TreeSitterLibrary.TSParser[])} and {@link #ts_parser_timeout_micros(treesitter.TreeSitterLibrary.TSParser)} instead
	 */
	@Deprecated
	long ts_parser_timeout_micros(TreeSitterLibrary.TSParser self);
	/**
	 * Get the duration in microseconds that parsing is allowed to take.<br>
	 * Original signature : <code>uint64_t ts_parser_timeout_micros(const TSParser*)</code><br>
	 * <i>native declaration : line 318</i>
	 */
	long ts_parser_timeout_micros(TreeSitterLibrary.TSParser self[]);
	/**
	 * Set the parser's current cancellation flag pointer.<br>
	 * * If a non-null pointer is assigned, then the parser will periodically read<br>
	 * from this pointer during parsing. If it reads a non-zero value, it will<br>
	 * halt early, returning NULL. See [`ts_parser_parse`] for more information.<br>
	 * Original signature : <code>void ts_parser_set_cancellation_flag(TSParser*, const size_t*)</code><br>
	 * <i>native declaration : line 327</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_set_cancellation_flag(treesitter.TreeSitterLibrary.TSParser, treesitter.NativeSize[])} and {@link #ts_parser_set_cancellation_flag(treesitter.TreeSitterLibrary.TSParser, treesitter.NativeSizeByReference)} instead
	 */
	@Deprecated
	void ts_parser_set_cancellation_flag(TreeSitterLibrary.TSParser self, NativeSizeByReference flag);
	/**
	 * Set the parser's current cancellation flag pointer.<br>
	 * * If a non-null pointer is assigned, then the parser will periodically read<br>
	 * from this pointer during parsing. If it reads a non-zero value, it will<br>
	 * halt early, returning NULL. See [`ts_parser_parse`] for more information.<br>
	 * Original signature : <code>void ts_parser_set_cancellation_flag(TSParser*, const size_t*)</code><br>
	 * <i>native declaration : line 327</i>
	 */
	void ts_parser_set_cancellation_flag(TreeSitterLibrary.TSParser self, NativeSize flag[]);
	/**
	 * Get the parser's current cancellation flag pointer.<br>
	 * Original signature : <code>size_t* ts_parser_cancellation_flag(const TSParser*)</code><br>
	 * <i>native declaration : line 332</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_cancellation_flag(treesitter.TreeSitterLibrary.TSParser[])} and {@link #ts_parser_cancellation_flag(treesitter.TreeSitterLibrary.TSParser)} instead
	 */
	@Deprecated
	NativeSizeByReference ts_parser_cancellation_flag(TreeSitterLibrary.TSParser self);
	/**
	 * Get the parser's current cancellation flag pointer.<br>
	 * Original signature : <code>size_t* ts_parser_cancellation_flag(const TSParser*)</code><br>
	 * <i>native declaration : line 332</i>
	 */
	NativeSizeByReference ts_parser_cancellation_flag(TreeSitterLibrary.TSParser self[]);
	/**
	 * Set the logger that a parser should use during parsing.<br>
	 * * The parser does not take ownership over the logger payload. If a logger was<br>
	 * previously assigned, the caller is responsible for releasing any memory<br>
	 * owned by the previous logger.<br>
	 * Original signature : <code>void ts_parser_set_logger(TSParser*, TSLogger)</code><br>
	 * <i>native declaration : line 341</i>
	 */
	void ts_parser_set_logger(TreeSitterLibrary.TSParser self, treesitter.TSLogger.ByValue logger);
	/**
	 * Get the parser's current logger.<br>
	 * Original signature : <code>TSLogger ts_parser_logger(const TSParser*)</code><br>
	 * <i>native declaration : line 346</i><br>
	 * @deprecated use the safer methods {@link #ts_parser_logger(treesitter.TreeSitterLibrary.TSParser[])} and {@link #ts_parser_logger(treesitter.TreeSitterLibrary.TSParser)} instead
	 */
	@Deprecated
	treesitter.TSLogger.ByValue ts_parser_logger(TreeSitterLibrary.TSParser self);
	/**
	 * Get the parser's current logger.<br>
	 * Original signature : <code>TSLogger ts_parser_logger(const TSParser*)</code><br>
	 * <i>native declaration : line 346</i>
	 */
	treesitter.TSLogger.ByValue ts_parser_logger(TreeSitterLibrary.TSParser self[]);
	/**
	 * Set the file descriptor to which the parser should write debugging graphs<br>
	 * during parsing. The graphs are formatted in the DOT language. You may want<br>
	 * to pipe these graphs directly to a `dot(1)` process in order to generate<br>
	 * SVG output. You can turn off this logging by passing a negative number.<br>
	 * Original signature : <code>void ts_parser_print_dot_graphs(TSParser*, int)</code><br>
	 * <i>native declaration : line 354</i>
	 */
	void ts_parser_print_dot_graphs(TreeSitterLibrary.TSParser self, int fd);
	/**
	 * Create a shallow copy of the syntax tree. This is very fast.<br>
	 * * You need to copy a syntax tree in order to use it on more than one thread at<br>
	 * a time, as syntax trees are not thread safe.<br>
	 * Original signature : <code>TSTree* ts_tree_copy(const TSTree*)</code><br>
	 * <i>native declaration : line 366</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_copy(treesitter.TreeSitterLibrary.TSTree[])} and {@link #ts_tree_copy(treesitter.TreeSitterLibrary.TSTree)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSTree ts_tree_copy(TreeSitterLibrary.TSTree self);
	/**
	 * Create a shallow copy of the syntax tree. This is very fast.<br>
	 * * You need to copy a syntax tree in order to use it on more than one thread at<br>
	 * a time, as syntax trees are not thread safe.<br>
	 * Original signature : <code>TSTree* ts_tree_copy(const TSTree*)</code><br>
	 * <i>native declaration : line 366</i>
	 */
	TreeSitterLibrary.TSTree ts_tree_copy(TreeSitterLibrary.TSTree self[]);
	/**
	 * Delete the syntax tree, freeing all of the memory that it used.<br>
	 * Original signature : <code>void ts_tree_delete(TSTree*)</code><br>
	 * <i>native declaration : line 371</i>
	 */
	void ts_tree_delete(TreeSitterLibrary.TSTree self);
	/**
	 * Get the root node of the syntax tree.<br>
	 * Original signature : <code>TSNode ts_tree_root_node(const TSTree*)</code><br>
	 * <i>native declaration : line 376</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_root_node(treesitter.TreeSitterLibrary.TSTree[])} and {@link #ts_tree_root_node(treesitter.TreeSitterLibrary.TSTree)} instead
	 */
	@Deprecated
	TSNode.ByValue ts_tree_root_node(TreeSitterLibrary.TSTree self);
	/**
	 * Get the root node of the syntax tree.<br>
	 * Original signature : <code>TSNode ts_tree_root_node(const TSTree*)</code><br>
	 * <i>native declaration : line 376</i>
	 */
	TSNode.ByValue ts_tree_root_node(TreeSitterLibrary.TSTree self[]);
	/**
	 * Get the root node of the syntax tree, but with its position<br>
	 * shifted forward by the given offset.<br>
	 * Original signature : <code>TSNode ts_tree_root_node_with_offset(const TSTree*, uint32_t, TSPoint)</code><br>
	 * <i>native declaration : line 382</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_root_node_with_offset(treesitter.TreeSitterLibrary.TSTree[], int, treesitter.TSPoint.ByValue)} and {@link #ts_tree_root_node_with_offset(treesitter.TreeSitterLibrary.TSTree, int, treesitter.TSPoint.ByValue)} instead
	 */
	@Deprecated
	TSNode.ByValue ts_tree_root_node_with_offset(TreeSitterLibrary.TSTree self, int offset_bytes, treesitter.TSPoint.ByValue offset_extent);
	/**
	 * Get the root node of the syntax tree, but with its position<br>
	 * shifted forward by the given offset.<br>
	 * Original signature : <code>TSNode ts_tree_root_node_with_offset(const TSTree*, uint32_t, TSPoint)</code><br>
	 * <i>native declaration : line 382</i>
	 */
	TSNode.ByValue ts_tree_root_node_with_offset(TreeSitterLibrary.TSTree self[], int offset_bytes, treesitter.TSPoint.ByValue offset_extent);
	/**
	 * Get the language that was used to parse the syntax tree.<br>
	 * Original signature : <code>TSLanguage* ts_tree_language(const TSTree*)</code><br>
	 * <i>native declaration : line 391</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_language(treesitter.TreeSitterLibrary.TSTree[])} and {@link #ts_tree_language(treesitter.TreeSitterLibrary.TSTree)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSLanguage ts_tree_language(TreeSitterLibrary.TSTree self);
	/**
	 * Get the language that was used to parse the syntax tree.<br>
	 * Original signature : <code>TSLanguage* ts_tree_language(const TSTree*)</code><br>
	 * <i>native declaration : line 391</i>
	 */
	TreeSitterLibrary.TSLanguage ts_tree_language(TreeSitterLibrary.TSTree self[]);
	/**
	 * Get the array of included ranges that was used to parse the syntax tree.<br>
	 * * The returned pointer must be freed by the caller.<br>
	 * Original signature : <code>TSRange* ts_tree_included_ranges(const TSTree*, uint32_t*)</code><br>
	 * <i>native declaration : line 398</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_included_ranges(treesitter.TreeSitterLibrary.TSTree[], java.nio.IntBuffer)} and {@link #ts_tree_included_ranges(treesitter.TreeSitterLibrary.TSTree, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	TSRange ts_tree_included_ranges(TreeSitterLibrary.TSTree self, IntByReference length);
	/**
	 * Get the array of included ranges that was used to parse the syntax tree.<br>
	 * * The returned pointer must be freed by the caller.<br>
	 * Original signature : <code>TSRange* ts_tree_included_ranges(const TSTree*, uint32_t*)</code><br>
	 * <i>native declaration : line 398</i>
	 */
	TSRange ts_tree_included_ranges(TreeSitterLibrary.TSTree self[], IntBuffer length);
	/**
	 * Edit the syntax tree to keep it in sync with source code that has been<br>
	 * edited.<br>
	 * * You must describe the edit both in terms of byte offsets and in terms of<br>
	 * (row, column) coordinates.<br>
	 * Original signature : <code>void ts_tree_edit(TSTree*, const TSInputEdit*)</code><br>
	 * <i>native declaration : line 407</i>
	 */
	void ts_tree_edit(TreeSitterLibrary.TSTree self, TSInputEdit edit);
	/**
	 * Compare an old edited syntax tree to a new syntax tree representing the same<br>
	 * document, returning an array of ranges whose syntactic structure has changed.<br>
	 * * For this to work correctly, the old syntax tree must have been edited such<br>
	 * that its ranges match up to the new tree. Generally, you'll want to call<br>
	 * this function right after calling one of the [`ts_parser_parse`] functions.<br>
	 * You need to pass the old tree that was passed to parse, as well as the new<br>
	 * tree that was returned from that function.<br>
	 * * The returned array is allocated using `malloc` and the caller is responsible<br>
	 * for freeing it using `free`. The length of the array will be written to the<br>
	 * given `length` pointer.<br>
	 * Original signature : <code>TSRange* ts_tree_get_changed_ranges(const TSTree*, const TSTree*, uint32_t*)</code><br>
	 * <i>native declaration : line 423</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_get_changed_ranges(treesitter.TreeSitterLibrary.TSTree[], treesitter.TreeSitterLibrary.TSTree[], java.nio.IntBuffer)} and {@link #ts_tree_get_changed_ranges(treesitter.TreeSitterLibrary.TSTree, treesitter.TreeSitterLibrary.TSTree, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	TSRange ts_tree_get_changed_ranges(TreeSitterLibrary.TSTree old_tree, TreeSitterLibrary.TSTree new_tree, IntByReference length);
	/**
	 * Compare an old edited syntax tree to a new syntax tree representing the same<br>
	 * document, returning an array of ranges whose syntactic structure has changed.<br>
	 * * For this to work correctly, the old syntax tree must have been edited such<br>
	 * that its ranges match up to the new tree. Generally, you'll want to call<br>
	 * this function right after calling one of the [`ts_parser_parse`] functions.<br>
	 * You need to pass the old tree that was passed to parse, as well as the new<br>
	 * tree that was returned from that function.<br>
	 * * The returned array is allocated using `malloc` and the caller is responsible<br>
	 * for freeing it using `free`. The length of the array will be written to the<br>
	 * given `length` pointer.<br>
	 * Original signature : <code>TSRange* ts_tree_get_changed_ranges(const TSTree*, const TSTree*, uint32_t*)</code><br>
	 * <i>native declaration : line 423</i>
	 */
	TSRange ts_tree_get_changed_ranges(TreeSitterLibrary.TSTree old_tree[], TreeSitterLibrary.TSTree new_tree[], IntBuffer length);
	/**
	 * Write a DOT graph describing the syntax tree to the given file.<br>
	 * Original signature : <code>void ts_tree_print_dot_graph(const TSTree*, int)</code><br>
	 * <i>native declaration : line 432</i><br>
	 * @deprecated use the safer methods {@link #ts_tree_print_dot_graph(treesitter.TreeSitterLibrary.TSTree[], int)} and {@link #ts_tree_print_dot_graph(treesitter.TreeSitterLibrary.TSTree, int)} instead
	 */
	@Deprecated
	void ts_tree_print_dot_graph(TreeSitterLibrary.TSTree self, int file_descriptor);
	/**
	 * Write a DOT graph describing the syntax tree to the given file.<br>
	 * Original signature : <code>void ts_tree_print_dot_graph(const TSTree*, int)</code><br>
	 * <i>native declaration : line 432</i>
	 */
	void ts_tree_print_dot_graph(TreeSitterLibrary.TSTree self[], int file_descriptor);
	/**
	 * Get the node's type as a null-terminated string.<br>
	 * Original signature : <code>char* ts_node_type(TSNode)</code><br>
	 * <i>native declaration : line 441</i>
	 */
	Pointer ts_node_type(TSNode.ByValue self);
	/**
	 * Get the node's type as a numerical id.<br>
	 * Original signature : <code>TSSymbol ts_node_symbol(TSNode)</code><br>
	 * <i>native declaration : line 446</i>
	 */
	short ts_node_symbol(TSNode.ByValue self);
	/**
	 * Get the node's language.<br>
	 * Original signature : <code>TSLanguage* ts_node_language(TSNode)</code><br>
	 * <i>native declaration : line 451</i>
	 */
	TreeSitterLibrary.TSLanguage ts_node_language(TSNode.ByValue self);
	/**
	 * Get the node's type as it appears in the grammar ignoring aliases as a<br>
	 * null-terminated string.<br>
	 * Original signature : <code>char* ts_node_grammar_type(TSNode)</code><br>
	 * <i>native declaration : line 457</i>
	 */
	Pointer ts_node_grammar_type(TSNode.ByValue self);
	/**
	 * Get the node's type as a numerical id as it appears in the grammar ignoring<br>
	 * aliases. This should be used in [`ts_language_next_state`] instead of<br>
	 * [`ts_node_symbol`].<br>
	 * Original signature : <code>TSSymbol ts_node_grammar_symbol(TSNode)</code><br>
	 * <i>native declaration : line 464</i>
	 */
	short ts_node_grammar_symbol(TSNode.ByValue self);
	/**
	 * Get the node's start byte.<br>
	 * Original signature : <code>uint32_t ts_node_start_byte(TSNode)</code><br>
	 * <i>native declaration : line 469</i>
	 */
	int ts_node_start_byte(TSNode.ByValue self);
	/**
	 * Get the node's start position in terms of rows and columns.<br>
	 * Original signature : <code>TSPoint ts_node_start_point(TSNode)</code><br>
	 * <i>native declaration : line 474</i>
	 */
	treesitter.TSPoint.ByValue ts_node_start_point(TSNode.ByValue self);
	/**
	 * Get the node's end byte.<br>
	 * Original signature : <code>uint32_t ts_node_end_byte(TSNode)</code><br>
	 * <i>native declaration : line 479</i>
	 */
	int ts_node_end_byte(TSNode.ByValue self);
	/**
	 * Get the node's end position in terms of rows and columns.<br>
	 * Original signature : <code>TSPoint ts_node_end_point(TSNode)</code><br>
	 * <i>native declaration : line 484</i>
	 */
	treesitter.TSPoint.ByValue ts_node_end_point(TSNode.ByValue self);
	/**
	 * Get an S-expression representing the node as a string.<br>
	 * * This string is allocated with `malloc` and the caller is responsible for<br>
	 * freeing it using `free`.<br>
	 * Original signature : <code>char* ts_node_string(TSNode)</code><br>
	 * <i>native declaration : line 492</i>
	 */
	Pointer ts_node_string(TSNode.ByValue self);
	/**
	 * Check if the node is null. Functions like [`ts_node_child`] and<br>
	 * [`ts_node_next_sibling`] will return a null node to indicate that no such node<br>
	 * was found.<br>
	 * Original signature : <code>bool ts_node_is_null(TSNode)</code><br>
	 * <i>native declaration : line 499</i>
	 */
	byte ts_node_is_null(TSNode.ByValue self);
	/**
	 * Check if the node is *named*. Named nodes correspond to named rules in the<br>
	 * grammar, whereas *anonymous* nodes correspond to string literals in the<br>
	 * grammar.<br>
	 * Original signature : <code>bool ts_node_is_named(TSNode)</code><br>
	 * <i>native declaration : line 506</i>
	 */
	byte ts_node_is_named(TSNode.ByValue self);
	/**
	 * Check if the node is *missing*. Missing nodes are inserted by the parser in<br>
	 * order to recover from certain kinds of syntax errors.<br>
	 * Original signature : <code>bool ts_node_is_missing(TSNode)</code><br>
	 * <i>native declaration : line 512</i>
	 */
	byte ts_node_is_missing(TSNode.ByValue self);
	/**
	 * Check if the node is *extra*. Extra nodes represent things like comments,<br>
	 * which are not required the grammar, but can appear anywhere.<br>
	 * Original signature : <code>bool ts_node_is_extra(TSNode)</code><br>
	 * <i>native declaration : line 518</i>
	 */
	byte ts_node_is_extra(TSNode.ByValue self);
	/**
	 * Check if a syntax node has been edited.<br>
	 * Original signature : <code>bool ts_node_has_changes(TSNode)</code><br>
	 * <i>native declaration : line 523</i>
	 */
	byte ts_node_has_changes(TSNode.ByValue self);
	/**
	 * Check if the node is a syntax error or contains any syntax errors.<br>
	 * Original signature : <code>bool ts_node_has_error(TSNode)</code><br>
	 * <i>native declaration : line 528</i>
	 */
	byte ts_node_has_error(TSNode.ByValue self);
	/**
	 * Check if the node is a syntax error.<br>
	 * Original signature : <code>bool ts_node_is_error(TSNode)</code><br>
	 * <i>native declaration : line 533</i>
	 */
	byte ts_node_is_error(TSNode.ByValue self);
	/**
	 * Get this node's parse state.<br>
	 * Original signature : <code>TSStateId ts_node_parse_state(TSNode)</code><br>
	 * <i>native declaration : line 538</i>
	 */
	short ts_node_parse_state(TSNode.ByValue self);
	/**
	 * Get the parse state after this node.<br>
	 * Original signature : <code>TSStateId ts_node_next_parse_state(TSNode)</code><br>
	 * <i>native declaration : line 543</i>
	 */
	short ts_node_next_parse_state(TSNode.ByValue self);
	/**
	 * Get the node's immediate parent.<br>
	 * Original signature : <code>TSNode ts_node_parent(TSNode)</code><br>
	 * <i>native declaration : line 548</i>
	 */
	TSNode.ByValue ts_node_parent(TSNode.ByValue self);
	/**
	 * Get the node's child at the given index, where zero represents the first<br>
	 * child.<br>
	 * Original signature : <code>TSNode ts_node_child(TSNode, uint32_t)</code><br>
	 * <i>native declaration : line 554</i>
	 */
	TSNode.ByValue ts_node_child(TSNode.ByValue self, int child_index);
	/**
	 * Get the field name for node's child at the given index, where zero represents<br>
	 * the first child. Returns NULL, if no field is found.<br>
	 * Original signature : <code>char* ts_node_field_name_for_child(TSNode, uint32_t)</code><br>
	 * <i>native declaration : line 560</i>
	 */
	Pointer ts_node_field_name_for_child(TSNode.ByValue self, int child_index);
	/**
	 * Get the node's number of children.<br>
	 * Original signature : <code>uint32_t ts_node_child_count(TSNode)</code><br>
	 * <i>native declaration : line 565</i>
	 */
	int ts_node_child_count(TSNode.ByValue self);
	/**
	 * Get the node's *named* child at the given index.<br>
	 * * See also [`ts_node_is_named`].<br>
	 * Original signature : <code>TSNode ts_node_named_child(TSNode, uint32_t)</code><br>
	 * <i>native declaration : line 572</i>
	 */
	TSNode.ByValue ts_node_named_child(TSNode.ByValue self, int child_index);
	/**
	 * Get the node's number of *named* children.<br>
	 * * See also [`ts_node_is_named`].<br>
	 * Original signature : <code>uint32_t ts_node_named_child_count(TSNode)</code><br>
	 * <i>native declaration : line 579</i>
	 */
	int ts_node_named_child_count(TSNode.ByValue self);
	/**
	 * Get the node's child with the given field name.<br>
	 * Original signature : <code>TSNode ts_node_child_by_field_name(TSNode, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 584</i><br>
	 * @deprecated use the safer methods {@link #ts_node_child_by_field_name(treesitter.TSNode.ByValue, java.lang.String, int)} and {@link #ts_node_child_by_field_name(treesitter.TSNode.ByValue, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated
	TSNode.ByValue ts_node_child_by_field_name(TSNode.ByValue self, Pointer name, int name_length);
	/**
	 * Get the node's child with the given field name.<br>
	 * Original signature : <code>TSNode ts_node_child_by_field_name(TSNode, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 584</i>
	 */
	TSNode.ByValue ts_node_child_by_field_name(TSNode.ByValue self, String name, int name_length);
	/**
	 * Get the node's child with the given numerical field id.<br>
	 * * You can convert a field name to an id using the<br>
	 * [`ts_language_field_id_for_name`] function.<br>
	 * Original signature : <code>TSNode ts_node_child_by_field_id(TSNode, TSFieldId)</code><br>
	 * <i>native declaration : line 596</i>
	 */
	TSNode.ByValue ts_node_child_by_field_id(TSNode.ByValue self, short field_id);
	/**
	 * Get the node's next / previous sibling.<br>
	 * Original signature : <code>TSNode ts_node_next_sibling(TSNode)</code><br>
	 * <i>native declaration : line 601</i>
	 */
	TSNode.ByValue ts_node_next_sibling(TSNode.ByValue self);
	/**
	 * Original signature : <code>TSNode ts_node_prev_sibling(TSNode)</code><br>
	 * <i>native declaration : line 602</i>
	 */
	TSNode.ByValue ts_node_prev_sibling(TSNode.ByValue self);
	/**
	 * Get the node's next / previous *named* sibling.<br>
	 * Original signature : <code>TSNode ts_node_next_named_sibling(TSNode)</code><br>
	 * <i>native declaration : line 607</i>
	 */
	TSNode.ByValue ts_node_next_named_sibling(TSNode.ByValue self);
	/**
	 * Original signature : <code>TSNode ts_node_prev_named_sibling(TSNode)</code><br>
	 * <i>native declaration : line 608</i>
	 */
	TSNode.ByValue ts_node_prev_named_sibling(TSNode.ByValue self);
	/**
	 * Get the node's first child that extends beyond the given byte offset.<br>
	 * Original signature : <code>TSNode ts_node_first_child_for_byte(TSNode, uint32_t)</code><br>
	 * <i>native declaration : line 613</i>
	 */
	TSNode.ByValue ts_node_first_child_for_byte(TSNode.ByValue self, int byte$);
	/**
	 * Get the node's first named child that extends beyond the given byte offset.<br>
	 * Original signature : <code>TSNode ts_node_first_named_child_for_byte(TSNode, uint32_t)</code><br>
	 * <i>native declaration : line 618</i>
	 */
	TSNode.ByValue ts_node_first_named_child_for_byte(TSNode.ByValue self, int byte$);
	/**
	 * Get the node's number of descendants, including one for the node itself.<br>
	 * Original signature : <code>uint32_t ts_node_descendant_count(TSNode)</code><br>
	 * <i>native declaration : line 623</i>
	 */
	int ts_node_descendant_count(TSNode.ByValue self);
	/**
	 * Get the smallest node within this node that spans the given range of bytes<br>
	 * or (row, column) positions.<br>
	 * Original signature : <code>TSNode ts_node_descendant_for_byte_range(TSNode, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : line 629</i>
	 */
	TSNode.ByValue ts_node_descendant_for_byte_range(TSNode.ByValue self, int start, int end);
	/**
	 * Original signature : <code>TSNode ts_node_descendant_for_point_range(TSNode, TSPoint, TSPoint)</code><br>
	 * <i>native declaration : line 630</i>
	 */
	TSNode.ByValue ts_node_descendant_for_point_range(TSNode.ByValue self, treesitter.TSPoint.ByValue start, treesitter.TSPoint.ByValue end);
	/**
	 * Get the smallest named node within this node that spans the given range of<br>
	 * bytes or (row, column) positions.<br>
	 * Original signature : <code>TSNode ts_node_named_descendant_for_byte_range(TSNode, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : line 636</i>
	 */
	TSNode.ByValue ts_node_named_descendant_for_byte_range(TSNode.ByValue self, int start, int end);
	/**
	 * Original signature : <code>TSNode ts_node_named_descendant_for_point_range(TSNode, TSPoint, TSPoint)</code><br>
	 * <i>native declaration : line 637</i>
	 */
	TSNode.ByValue ts_node_named_descendant_for_point_range(TSNode.ByValue self, treesitter.TSPoint.ByValue start, treesitter.TSPoint.ByValue end);
	/**
	 * Edit the node to keep it in-sync with source code that has been edited.<br>
	 * * This function is only rarely needed. When you edit a syntax tree with the<br>
	 * [`ts_tree_edit`] function, all of the nodes that you retrieve from the tree<br>
	 * afterward will already reflect the edit. You only need to use [`ts_node_edit`]<br>
	 * when you have a [`TSNode`] instance that you want to keep and continue to use<br>
	 * after an edit.<br>
	 * Original signature : <code>void ts_node_edit(TSNode*, const TSInputEdit*)</code><br>
	 * <i>native declaration : line 648</i>
	 */
	void ts_node_edit(TSNode self, TSInputEdit edit);
	/**
	 * Check if two nodes are identical.<br>
	 * Original signature : <code>bool ts_node_eq(TSNode, TSNode)</code><br>
	 * <i>native declaration : line 653</i>
	 */
	byte ts_node_eq(TSNode.ByValue self, TSNode.ByValue other);
	/**
	 * Create a new tree cursor starting from the given node.<br>
	 * * A tree cursor allows you to walk a syntax tree more efficiently than is<br>
	 * possible using the [`TSNode`] functions. It is a mutable object that is always<br>
	 * on a certain syntax node, and can be moved imperatively to different nodes.<br>
	 * Original signature : <code>TSTreeCursor ts_tree_cursor_new(TSNode)</code><br>
	 * <i>native declaration : line 666</i>
	 */
	TSTreeCursor.ByValue ts_tree_cursor_new(TSNode.ByValue node);
	/**
	 * Delete a tree cursor, freeing all of the memory that it used.<br>
	 * Original signature : <code>void ts_tree_cursor_delete(TSTreeCursor*)</code><br>
	 * <i>native declaration : line 671</i>
	 */
	void ts_tree_cursor_delete(TSTreeCursor self);
	/**
	 * Re-initialize a tree cursor to start at a different node.<br>
	 * Original signature : <code>void ts_tree_cursor_reset(TSTreeCursor*, TSNode)</code><br>
	 * <i>native declaration : line 676</i>
	 */
	void ts_tree_cursor_reset(TSTreeCursor self, TSNode.ByValue node);
	/**
	 * Re-initialize a tree cursor to the same position as another cursor.<br>
	 * * Unlike [`ts_tree_cursor_reset`], this will not lose parent information and<br>
	 * allows reusing already created cursors.<br>
	 * Original signature : <code>void ts_tree_cursor_reset_to(TSTreeCursor*, const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 684</i>
	 */
	void ts_tree_cursor_reset_to(TSTreeCursor dst, TSTreeCursor src);
	/**
	 * Get the tree cursor's current node.<br>
	 * Original signature : <code>TSNode ts_tree_cursor_current_node(const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 689</i>
	 */
	TSNode.ByValue ts_tree_cursor_current_node(TSTreeCursor self);
	/**
	 * Get the field name of the tree cursor's current node.<br>
	 * * This returns `NULL` if the current node doesn't have a field.<br>
	 * See also [`ts_node_child_by_field_name`].<br>
	 * Original signature : <code>char* ts_tree_cursor_current_field_name(const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 697</i>
	 */
	Pointer ts_tree_cursor_current_field_name(TSTreeCursor self);
	/**
	 * Get the field id of the tree cursor's current node.<br>
	 * * This returns zero if the current node doesn't have a field.<br>
	 * See also [`ts_node_child_by_field_id`], [`ts_language_field_id_for_name`].<br>
	 * Original signature : <code>TSFieldId ts_tree_cursor_current_field_id(const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 705</i>
	 */
	short ts_tree_cursor_current_field_id(TSTreeCursor self);
	/**
	 * Move the cursor to the parent of its current node.<br>
	 * * This returns `true` if the cursor successfully moved, and returns `false`<br>
	 * if there was no parent node (the cursor was already on the root node).<br>
	 * Original signature : <code>bool ts_tree_cursor_goto_parent(TSTreeCursor*)</code><br>
	 * <i>native declaration : line 713</i>
	 */
	byte ts_tree_cursor_goto_parent(TSTreeCursor self);
	/**
	 * Move the cursor to the next sibling of its current node.<br>
	 * * This returns `true` if the cursor successfully moved, and returns `false`<br>
	 * if there was no next sibling node.<br>
	 * Original signature : <code>bool ts_tree_cursor_goto_next_sibling(TSTreeCursor*)</code><br>
	 * <i>native declaration : line 721</i>
	 */
	byte ts_tree_cursor_goto_next_sibling(TSTreeCursor self);
	/**
	 * Move the cursor to the previous sibling of its current node.<br>
	 * * This returns `true` if the cursor successfully moved, and returns `false` if<br>
	 * there was no previous sibling node.<br>
	 * * Note, that this function may be slower than<br>
	 * [`ts_tree_cursor_goto_next_sibling`] due to how node positions are stored. In<br>
	 * the worst case, this will need to iterate through all the children upto the<br>
	 * previous sibling node to recalculate its position.<br>
	 * Original signature : <code>bool ts_tree_cursor_goto_previous_sibling(TSTreeCursor*)</code><br>
	 * <i>native declaration : line 734</i>
	 */
	byte ts_tree_cursor_goto_previous_sibling(TSTreeCursor self);
	/**
	 * Move the cursor to the first child of its current node.<br>
	 * * This returns `true` if the cursor successfully moved, and returns `false`<br>
	 * if there were no children.<br>
	 * Original signature : <code>bool ts_tree_cursor_goto_first_child(TSTreeCursor*)</code><br>
	 * <i>native declaration : line 742</i>
	 */
	byte ts_tree_cursor_goto_first_child(TSTreeCursor self);
	/**
	 * Move the cursor to the last child of its current node.<br>
	 * * This returns `true` if the cursor successfully moved, and returns `false` if<br>
	 * there were no children.<br>
	 * * Note that this function may be slower than [`ts_tree_cursor_goto_first_child`]<br>
	 * because it needs to iterate through all the children to compute the child's<br>
	 * position.<br>
	 * Original signature : <code>bool ts_tree_cursor_goto_last_child(TSTreeCursor*)</code><br>
	 * <i>native declaration : line 754</i>
	 */
	byte ts_tree_cursor_goto_last_child(TSTreeCursor self);
	/**
	 * Move the cursor to the node that is the nth descendant of<br>
	 * the original node that the cursor was constructed with, where<br>
	 * zero represents the original node itself.<br>
	 * Original signature : <code>void ts_tree_cursor_goto_descendant(TSTreeCursor*, uint32_t)</code><br>
	 * <i>native declaration : line 761</i>
	 */
	void ts_tree_cursor_goto_descendant(TSTreeCursor self, int goal_descendant_index);
	/**
	 * Get the index of the cursor's current node out of all of the<br>
	 * descendants of the original node that the cursor was constructed with.<br>
	 * Original signature : <code>uint32_t ts_tree_cursor_current_descendant_index(const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 767</i>
	 */
	int ts_tree_cursor_current_descendant_index(TSTreeCursor self);
	/**
	 * Get the depth of the cursor's current node relative to the original<br>
	 * node that the cursor was constructed with.<br>
	 * Original signature : <code>uint32_t ts_tree_cursor_current_depth(const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 773</i>
	 */
	int ts_tree_cursor_current_depth(TSTreeCursor self);
	/**
	 * Move the cursor to the first child of its current node that extends beyond<br>
	 * the given byte offset or point.<br>
	 * * This returns the index of the child node if one was found, and returns -1<br>
	 * if no such child was found.<br>
	 * Original signature : <code>int64_t ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor*, uint32_t)</code><br>
	 * <i>native declaration : line 782</i>
	 */
	long ts_tree_cursor_goto_first_child_for_byte(TSTreeCursor self, int goal_byte);
	/**
	 * Original signature : <code>int64_t ts_tree_cursor_goto_first_child_for_point(TSTreeCursor*, TSPoint)</code><br>
	 * <i>native declaration : line 783</i>
	 */
	long ts_tree_cursor_goto_first_child_for_point(TSTreeCursor self, treesitter.TSPoint.ByValue goal_point);
	/**
	 * Original signature : <code>TSTreeCursor ts_tree_cursor_copy(const TSTreeCursor*)</code><br>
	 * <i>native declaration : line 785</i>
	 */
	TSTreeCursor.ByValue ts_tree_cursor_copy(TSTreeCursor cursor);
	/**
	 * Create a new query from a string containing one or more S-expression<br>
	 * patterns. The query is associated with a particular language, and can<br>
	 * only be run on syntax nodes parsed with that language.<br>
	 * * If all of the given patterns are valid, this returns a [`TSQuery`].<br>
	 * If a pattern is invalid, this returns `NULL`, and provides two pieces<br>
	 * of information about the problem:<br>
	 * 1. The byte offset of the error is written to the `error_offset` parameter.<br>
	 * 2. The type of error is written to the `error_type` parameter.<br>
	 * Original signature : <code>TSQuery* ts_query_new(const TSLanguage*, const char*, uint32_t, uint32_t*, TSQueryError*)</code><br>
	 * <i>native declaration : line 802</i><br>
	 * @deprecated use the safer methods {@link #ts_query_new(treesitter.TreeSitterLibrary.TSLanguage[], java.lang.String, int, java.nio.IntBuffer, java.nio.IntBuffer)} and {@link #ts_query_new(treesitter.TreeSitterLibrary.TSLanguage, com.sun.jna.Pointer, int, com.sun.jna.ptr.IntByReference, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSQuery ts_query_new(TreeSitterLibrary.TSLanguage language, Pointer source, int source_len, IntByReference error_offset, IntByReference error_type);
	/**
	 * Create a new query from a string containing one or more S-expression<br>
	 * patterns. The query is associated with a particular language, and can<br>
	 * only be run on syntax nodes parsed with that language.<br>
	 * * If all of the given patterns are valid, this returns a [`TSQuery`].<br>
	 * If a pattern is invalid, this returns `NULL`, and provides two pieces<br>
	 * of information about the problem:<br>
	 * 1. The byte offset of the error is written to the `error_offset` parameter.<br>
	 * 2. The type of error is written to the `error_type` parameter.<br>
	 * Original signature : <code>TSQuery* ts_query_new(const TSLanguage*, const char*, uint32_t, uint32_t*, TSQueryError*)</code><br>
	 * <i>native declaration : line 802</i>
	 */
	TreeSitterLibrary.TSQuery ts_query_new(TreeSitterLibrary.TSLanguage language[], String source, int source_len, IntBuffer error_offset, IntBuffer error_type);
	/**
	 * Delete a query, freeing all of the memory that it used.<br>
	 * Original signature : <code>void ts_query_delete(TSQuery*)</code><br>
	 * <i>native declaration : line 813</i>
	 */
	void ts_query_delete(TreeSitterLibrary.TSQuery self);
	/**
	 * Get the number of patterns, captures, or string literals in the query.<br>
	 * Original signature : <code>uint32_t ts_query_pattern_count(const TSQuery*)</code><br>
	 * <i>native declaration : line 818</i><br>
	 * @deprecated use the safer methods {@link #ts_query_pattern_count(treesitter.TreeSitterLibrary.TSQuery[])} and {@link #ts_query_pattern_count(treesitter.TreeSitterLibrary.TSQuery)} instead
	 */
	@Deprecated
	int ts_query_pattern_count(TreeSitterLibrary.TSQuery self);
	/**
	 * Get the number of patterns, captures, or string literals in the query.<br>
	 * Original signature : <code>uint32_t ts_query_pattern_count(const TSQuery*)</code><br>
	 * <i>native declaration : line 818</i>
	 */
	int ts_query_pattern_count(TreeSitterLibrary.TSQuery self[]);
	/**
	 * Original signature : <code>uint32_t ts_query_capture_count(const TSQuery*)</code><br>
	 * <i>native declaration : line 819</i><br>
	 * @deprecated use the safer methods {@link #ts_query_capture_count(treesitter.TreeSitterLibrary.TSQuery[])} and {@link #ts_query_capture_count(treesitter.TreeSitterLibrary.TSQuery)} instead
	 */
	@Deprecated
	int ts_query_capture_count(TreeSitterLibrary.TSQuery self);
	/**
	 * Original signature : <code>uint32_t ts_query_capture_count(const TSQuery*)</code><br>
	 * <i>native declaration : line 819</i>
	 */
	int ts_query_capture_count(TreeSitterLibrary.TSQuery self[]);
	/**
	 * Original signature : <code>uint32_t ts_query_string_count(const TSQuery*)</code><br>
	 * <i>native declaration : line 820</i><br>
	 * @deprecated use the safer methods {@link #ts_query_string_count(treesitter.TreeSitterLibrary.TSQuery[])} and {@link #ts_query_string_count(treesitter.TreeSitterLibrary.TSQuery)} instead
	 */
	@Deprecated
	int ts_query_string_count(TreeSitterLibrary.TSQuery self);
	/**
	 * Original signature : <code>uint32_t ts_query_string_count(const TSQuery*)</code><br>
	 * <i>native declaration : line 820</i>
	 */
	int ts_query_string_count(TreeSitterLibrary.TSQuery self[]);
	/**
	 * Get the byte offset where the given pattern starts in the query's source.<br>
	 * * This can be useful when combining queries by concatenating their source<br>
	 * code strings.<br>
	 * Original signature : <code>uint32_t ts_query_start_byte_for_pattern(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 828</i><br>
	 * @deprecated use the safer methods {@link #ts_query_start_byte_for_pattern(treesitter.TreeSitterLibrary.TSQuery[], int)} and {@link #ts_query_start_byte_for_pattern(treesitter.TreeSitterLibrary.TSQuery, int)} instead
	 */
	@Deprecated
	int ts_query_start_byte_for_pattern(TreeSitterLibrary.TSQuery self, int pattern_index);
	/**
	 * Get the byte offset where the given pattern starts in the query's source.<br>
	 * * This can be useful when combining queries by concatenating their source<br>
	 * code strings.<br>
	 * Original signature : <code>uint32_t ts_query_start_byte_for_pattern(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 828</i>
	 */
	int ts_query_start_byte_for_pattern(TreeSitterLibrary.TSQuery self[], int pattern_index);
	/**
	 * Get all of the predicates for the given pattern in the query.<br>
	 * * The predicates are represented as a single array of steps. There are three<br>
	 * types of steps in this array, which correspond to the three legal values for<br>
	 * the `type` field:<br>
	 * - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names<br>
	 *    of captures. Their `value_id` can be used with the<br>
	 *   [`ts_query_capture_name_for_id`] function to obtain the name of the capture.<br>
	 * - `TSQueryPredicateStepTypeString` - Steps with this type represent literal<br>
	 *    strings. Their `value_id` can be used with the<br>
	 *    [`ts_query_string_value_for_id`] function to obtain their string value.<br>
	 * - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*<br>
	 *    that represent the end of an individual predicate. If a pattern has two<br>
	 *    predicates, then there will be two steps with this `type` in the array.<br>
	 * Original signature : <code>TSQueryPredicateStep* ts_query_predicates_for_pattern(const TSQuery*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : line 846</i><br>
	 * @deprecated use the safer methods {@link #ts_query_predicates_for_pattern(treesitter.TreeSitterLibrary.TSQuery[], int, java.nio.IntBuffer)} and {@link #ts_query_predicates_for_pattern(treesitter.TreeSitterLibrary.TSQuery, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	TSQueryPredicateStep ts_query_predicates_for_pattern(TreeSitterLibrary.TSQuery self, int pattern_index, IntByReference step_count);
	/**
	 * Get all of the predicates for the given pattern in the query.<br>
	 * * The predicates are represented as a single array of steps. There are three<br>
	 * types of steps in this array, which correspond to the three legal values for<br>
	 * the `type` field:<br>
	 * - `TSQueryPredicateStepTypeCapture` - Steps with this type represent names<br>
	 *    of captures. Their `value_id` can be used with the<br>
	 *   [`ts_query_capture_name_for_id`] function to obtain the name of the capture.<br>
	 * - `TSQueryPredicateStepTypeString` - Steps with this type represent literal<br>
	 *    strings. Their `value_id` can be used with the<br>
	 *    [`ts_query_string_value_for_id`] function to obtain their string value.<br>
	 * - `TSQueryPredicateStepTypeDone` - Steps with this type are *sentinels*<br>
	 *    that represent the end of an individual predicate. If a pattern has two<br>
	 *    predicates, then there will be two steps with this `type` in the array.<br>
	 * Original signature : <code>TSQueryPredicateStep* ts_query_predicates_for_pattern(const TSQuery*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : line 846</i>
	 */
	TSQueryPredicateStep ts_query_predicates_for_pattern(TreeSitterLibrary.TSQuery self[], int pattern_index, IntBuffer step_count);
	/**
	 * Check if the given pattern in the query has a single root node.<br>
	 * Original signature : <code>bool ts_query_is_pattern_rooted(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 855</i><br>
	 * @deprecated use the safer methods {@link #ts_query_is_pattern_rooted(treesitter.TreeSitterLibrary.TSQuery[], int)} and {@link #ts_query_is_pattern_rooted(treesitter.TreeSitterLibrary.TSQuery, int)} instead
	 */
	@Deprecated
	byte ts_query_is_pattern_rooted(TreeSitterLibrary.TSQuery self, int pattern_index);
	/**
	 * Check if the given pattern in the query has a single root node.<br>
	 * Original signature : <code>bool ts_query_is_pattern_rooted(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 855</i>
	 */
	byte ts_query_is_pattern_rooted(TreeSitterLibrary.TSQuery self[], int pattern_index);
	/**
	 * Check if the given pattern in the query is 'non local'.<br>
	 * * A non-local pattern has multiple root nodes and can match within a<br>
	 * repeating sequence of nodes, as specified by the grammar. Non-local<br>
	 * patterns disable certain optimizations that would otherwise be possible<br>
	 * when executing a query on a specific range of a syntax tree.<br>
	 * Original signature : <code>bool ts_query_is_pattern_non_local(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 865</i><br>
	 * @deprecated use the safer methods {@link #ts_query_is_pattern_non_local(treesitter.TreeSitterLibrary.TSQuery[], int)} and {@link #ts_query_is_pattern_non_local(treesitter.TreeSitterLibrary.TSQuery, int)} instead
	 */
	@Deprecated
	byte ts_query_is_pattern_non_local(TreeSitterLibrary.TSQuery self, int pattern_index);
	/**
	 * Check if the given pattern in the query is 'non local'.<br>
	 * * A non-local pattern has multiple root nodes and can match within a<br>
	 * repeating sequence of nodes, as specified by the grammar. Non-local<br>
	 * patterns disable certain optimizations that would otherwise be possible<br>
	 * when executing a query on a specific range of a syntax tree.<br>
	 * Original signature : <code>bool ts_query_is_pattern_non_local(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 865</i>
	 */
	byte ts_query_is_pattern_non_local(TreeSitterLibrary.TSQuery self[], int pattern_index);
	/**
	 * Check if a given pattern is guaranteed to match once a given step is reached.<br>
	 * The step is specified by its byte offset in the query's source code.<br>
	 * Original signature : <code>bool ts_query_is_pattern_guaranteed_at_step(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 871</i><br>
	 * @deprecated use the safer methods {@link #ts_query_is_pattern_guaranteed_at_step(treesitter.TreeSitterLibrary.TSQuery[], int)} and {@link #ts_query_is_pattern_guaranteed_at_step(treesitter.TreeSitterLibrary.TSQuery, int)} instead
	 */
	@Deprecated
	byte ts_query_is_pattern_guaranteed_at_step(TreeSitterLibrary.TSQuery self, int byte_offset);
	/**
	 * Check if a given pattern is guaranteed to match once a given step is reached.<br>
	 * The step is specified by its byte offset in the query's source code.<br>
	 * Original signature : <code>bool ts_query_is_pattern_guaranteed_at_step(const TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 871</i>
	 */
	byte ts_query_is_pattern_guaranteed_at_step(TreeSitterLibrary.TSQuery self[], int byte_offset);
	/**
	 * Get the name and length of one of the query's captures, or one of the<br>
	 * query's string literals. Each capture and string is associated with a<br>
	 * numeric id based on the order that it appeared in the query's source.<br>
	 * Original signature : <code>char* ts_query_capture_name_for_id(const TSQuery*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : line 878</i><br>
	 * @deprecated use the safer methods {@link #ts_query_capture_name_for_id(treesitter.TreeSitterLibrary.TSQuery[], int, java.nio.IntBuffer)} and {@link #ts_query_capture_name_for_id(treesitter.TreeSitterLibrary.TSQuery, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	Pointer ts_query_capture_name_for_id(TreeSitterLibrary.TSQuery self, int index, IntByReference length);
	/**
	 * Get the name and length of one of the query's captures, or one of the<br>
	 * query's string literals. Each capture and string is associated with a<br>
	 * numeric id based on the order that it appeared in the query's source.<br>
	 * Original signature : <code>char* ts_query_capture_name_for_id(const TSQuery*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : line 878</i>
	 */
	Pointer ts_query_capture_name_for_id(TreeSitterLibrary.TSQuery self[], int index, IntBuffer length);
	/**
	 * Get the quantifier of the query's captures. Each capture is * associated<br>
	 * with a numeric id based on the order that it appeared in the query's source.<br>
	 * Original signature : <code>TSQuantifier ts_query_capture_quantifier_for_id(const TSQuery*, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : line 888</i><br>
	 * @deprecated use the safer methods {@link #ts_query_capture_quantifier_for_id(treesitter.TreeSitterLibrary.TSQuery[], int, int)} and {@link #ts_query_capture_quantifier_for_id(treesitter.TreeSitterLibrary.TSQuery, int, int)} instead
	 */
	@Deprecated
	int ts_query_capture_quantifier_for_id(TreeSitterLibrary.TSQuery self, int pattern_index, int capture_index);
	/**
	 * Get the quantifier of the query's captures. Each capture is * associated<br>
	 * with a numeric id based on the order that it appeared in the query's source.<br>
	 * Original signature : <code>TSQuantifier ts_query_capture_quantifier_for_id(const TSQuery*, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : line 888</i>
	 */
	int ts_query_capture_quantifier_for_id(TreeSitterLibrary.TSQuery self[], int pattern_index, int capture_index);
	/**
	 * Original signature : <code>char* ts_query_string_value_for_id(const TSQuery*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : line 894</i><br>
	 * @deprecated use the safer methods {@link #ts_query_string_value_for_id(treesitter.TreeSitterLibrary.TSQuery[], int, java.nio.IntBuffer)} and {@link #ts_query_string_value_for_id(treesitter.TreeSitterLibrary.TSQuery, int, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	Pointer ts_query_string_value_for_id(TreeSitterLibrary.TSQuery self, int index, IntByReference length);
	/**
	 * Original signature : <code>char* ts_query_string_value_for_id(const TSQuery*, uint32_t, uint32_t*)</code><br>
	 * <i>native declaration : line 894</i>
	 */
	Pointer ts_query_string_value_for_id(TreeSitterLibrary.TSQuery self[], int index, IntBuffer length);
	/**
	 * Disable a certain capture within a query.<br>
	 * * This prevents the capture from being returned in matches, and also avoids<br>
	 * any resource usage associated with recording the capture. Currently, there<br>
	 * is no way to undo this.<br>
	 * Original signature : <code>void ts_query_disable_capture(TSQuery*, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 907</i><br>
	 * @deprecated use the safer methods {@link #ts_query_disable_capture(treesitter.TreeSitterLibrary.TSQuery, java.lang.String, int)} and {@link #ts_query_disable_capture(treesitter.TreeSitterLibrary.TSQuery, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated
	void ts_query_disable_capture(TreeSitterLibrary.TSQuery self, Pointer name, int length);
	/**
	 * Disable a certain capture within a query.<br>
	 * * This prevents the capture from being returned in matches, and also avoids<br>
	 * any resource usage associated with recording the capture. Currently, there<br>
	 * is no way to undo this.<br>
	 * Original signature : <code>void ts_query_disable_capture(TSQuery*, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 907</i>
	 */
	void ts_query_disable_capture(TreeSitterLibrary.TSQuery self, String name, int length);
	/**
	 * Disable a certain pattern within a query.<br>
	 * * This prevents the pattern from matching and removes most of the overhead<br>
	 * associated with the pattern. Currently, there is no way to undo this.<br>
	 * Original signature : <code>void ts_query_disable_pattern(TSQuery*, uint32_t)</code><br>
	 * <i>native declaration : line 915</i>
	 */
	void ts_query_disable_pattern(TreeSitterLibrary.TSQuery self, int pattern_index);
	/**
	 * Create a new cursor for executing a given query.<br>
	 * * The cursor stores the state that is needed to iteratively search<br>
	 * for matches. To use the query cursor, first call [`ts_query_cursor_exec`]<br>
	 * to start running a given query on a given syntax node. Then, there are<br>
	 * two options for consuming the results of the query:<br>
	 * 1. Repeatedly call [`ts_query_cursor_next_match`] to iterate over all of the<br>
	 *    *matches* in the order that they were found. Each match contains the<br>
	 *    index of the pattern that matched, and an array of captures. Because<br>
	 *    multiple patterns can match the same set of nodes, one match may contain<br>
	 *    captures that appear *before* some of the captures from a previous match.<br>
	 * 2. Repeatedly call [`ts_query_cursor_next_capture`] to iterate over all of the<br>
	 *    individual *captures* in the order that they appear. This is useful if<br>
	 *    don't care about which pattern matched, and just want a single ordered<br>
	 *    sequence of captures.<br>
	 * * If you don't care about consuming all of the results, you can stop calling<br>
	 * [`ts_query_cursor_next_match`] or [`ts_query_cursor_next_capture`] at any point.<br>
	 *  You can then start executing another query on another node by calling<br>
	 *  [`ts_query_cursor_exec`] again.<br>
	 * Original signature : <code>TSQueryCursor* ts_query_cursor_new()</code><br>
	 * <i>native declaration : line 939</i>
	 */
	TreeSitterLibrary.TSQueryCursor ts_query_cursor_new();
	/**
	 * Delete a query cursor, freeing all of the memory that it used.<br>
	 * Original signature : <code>void ts_query_cursor_delete(TSQueryCursor*)</code><br>
	 * <i>native declaration : line 944</i>
	 */
	void ts_query_cursor_delete(TreeSitterLibrary.TSQueryCursor self);
	/**
	 * Start running a given query on a given node.<br>
	 * Original signature : <code>void ts_query_cursor_exec(TSQueryCursor*, const TSQuery*, TSNode)</code><br>
	 * <i>native declaration : line 949</i><br>
	 * @deprecated use the safer methods {@link #ts_query_cursor_exec(treesitter.TreeSitterLibrary.TSQueryCursor, treesitter.TreeSitterLibrary.TSQuery[], treesitter.TSNode.ByValue)} and {@link #ts_query_cursor_exec(treesitter.TreeSitterLibrary.TSQueryCursor, treesitter.TreeSitterLibrary.TSQuery, treesitter.TSNode.ByValue)} instead
	 */
	@Deprecated
	void ts_query_cursor_exec(TreeSitterLibrary.TSQueryCursor self, TreeSitterLibrary.TSQuery query, TSNode.ByValue node);
	/**
	 * Start running a given query on a given node.<br>
	 * Original signature : <code>void ts_query_cursor_exec(TSQueryCursor*, const TSQuery*, TSNode)</code><br>
	 * <i>native declaration : line 949</i>
	 */
	void ts_query_cursor_exec(TreeSitterLibrary.TSQueryCursor self, TreeSitterLibrary.TSQuery query[], TSNode.ByValue node);
	/**
	 * Manage the maximum number of in-progress matches allowed by this query<br>
	 * cursor.<br>
	 * * Query cursors have an optional maximum capacity for storing lists of<br>
	 * in-progress captures. If this capacity is exceeded, then the<br>
	 * earliest-starting match will silently be dropped to make room for further<br>
	 * matches. This maximum capacity is optional \u2014 by default, query cursors allow<br>
	 * any number of pending matches, dynamically allocating new space for them as<br>
	 * needed as the query is executed.<br>
	 * Original signature : <code>bool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor*)</code><br>
	 * <i>native declaration : line 962</i><br>
	 * @deprecated use the safer methods {@link #ts_query_cursor_did_exceed_match_limit(treesitter.TreeSitterLibrary.TSQueryCursor[])} and {@link #ts_query_cursor_did_exceed_match_limit(treesitter.TreeSitterLibrary.TSQueryCursor)} instead
	 */
	@Deprecated
	byte ts_query_cursor_did_exceed_match_limit(TreeSitterLibrary.TSQueryCursor self);
	/**
	 * Manage the maximum number of in-progress matches allowed by this query<br>
	 * cursor.<br>
	 * * Query cursors have an optional maximum capacity for storing lists of<br>
	 * in-progress captures. If this capacity is exceeded, then the<br>
	 * earliest-starting match will silently be dropped to make room for further<br>
	 * matches. This maximum capacity is optional \u2014 by default, query cursors allow<br>
	 * any number of pending matches, dynamically allocating new space for them as<br>
	 * needed as the query is executed.<br>
	 * Original signature : <code>bool ts_query_cursor_did_exceed_match_limit(const TSQueryCursor*)</code><br>
	 * <i>native declaration : line 962</i>
	 */
	byte ts_query_cursor_did_exceed_match_limit(TreeSitterLibrary.TSQueryCursor self[]);
	/**
	 * Original signature : <code>uint32_t ts_query_cursor_match_limit(const TSQueryCursor*)</code><br>
	 * <i>native declaration : line 963</i><br>
	 * @deprecated use the safer methods {@link #ts_query_cursor_match_limit(treesitter.TreeSitterLibrary.TSQueryCursor[])} and {@link #ts_query_cursor_match_limit(treesitter.TreeSitterLibrary.TSQueryCursor)} instead
	 */
	@Deprecated
	int ts_query_cursor_match_limit(TreeSitterLibrary.TSQueryCursor self);
	/**
	 * Original signature : <code>uint32_t ts_query_cursor_match_limit(const TSQueryCursor*)</code><br>
	 * <i>native declaration : line 963</i>
	 */
	int ts_query_cursor_match_limit(TreeSitterLibrary.TSQueryCursor self[]);
	/**
	 * Original signature : <code>void ts_query_cursor_set_match_limit(TSQueryCursor*, uint32_t)</code><br>
	 * <i>native declaration : line 964</i>
	 */
	void ts_query_cursor_set_match_limit(TreeSitterLibrary.TSQueryCursor self, int limit);
	/**
	 * Set the range of bytes or (row, column) positions in which the query<br>
	 * will be executed.<br>
	 * Original signature : <code>void ts_query_cursor_set_byte_range(TSQueryCursor*, uint32_t, uint32_t)</code><br>
	 * <i>native declaration : line 970</i>
	 */
	void ts_query_cursor_set_byte_range(TreeSitterLibrary.TSQueryCursor self, int start_byte, int end_byte);
	/**
	 * Original signature : <code>void ts_query_cursor_set_point_range(TSQueryCursor*, TSPoint, TSPoint)</code><br>
	 * <i>native declaration : line 971</i>
	 */
	void ts_query_cursor_set_point_range(TreeSitterLibrary.TSQueryCursor self, treesitter.TSPoint.ByValue start_point, treesitter.TSPoint.ByValue end_point);
	/**
	 * Advance to the next match of the currently running query.<br>
	 * * If there is a match, write it to `*match` and return `true`.<br>
	 * Otherwise, return `false`.<br>
	 * Original signature : <code>bool ts_query_cursor_next_match(TSQueryCursor*, TSQueryMatch*)</code><br>
	 * <i>native declaration : line 979</i>
	 */
	byte ts_query_cursor_next_match(TreeSitterLibrary.TSQueryCursor self, TSQueryMatch match);
	/**
	 * Original signature : <code>void ts_query_cursor_remove_match(TSQueryCursor*, uint32_t)</code><br>
	 * <i>native declaration : line 980</i>
	 */
	void ts_query_cursor_remove_match(TreeSitterLibrary.TSQueryCursor self, int match_id);
	/**
	 * Advance to the next capture of the currently running query.<br>
	 * * If there is a capture, write its match to `*match` and its index within<br>
	 * the matche's capture list to `*capture_index`. Otherwise, return `false`.<br>
	 * Original signature : <code>bool ts_query_cursor_next_capture(TSQueryCursor*, TSQueryMatch*, uint32_t*)</code><br>
	 * <i>native declaration : line 988</i><br>
	 * @deprecated use the safer methods {@link #ts_query_cursor_next_capture(treesitter.TreeSitterLibrary.TSQueryCursor, treesitter.TSQueryMatch, java.nio.IntBuffer)} and {@link #ts_query_cursor_next_capture(treesitter.TreeSitterLibrary.TSQueryCursor, treesitter.TSQueryMatch, com.sun.jna.ptr.IntByReference)} instead
	 */
	@Deprecated
	byte ts_query_cursor_next_capture(TreeSitterLibrary.TSQueryCursor self, TSQueryMatch match, IntByReference capture_index);
	/**
	 * Advance to the next capture of the currently running query.<br>
	 * * If there is a capture, write its match to `*match` and its index within<br>
	 * the matche's capture list to `*capture_index`. Otherwise, return `false`.<br>
	 * Original signature : <code>bool ts_query_cursor_next_capture(TSQueryCursor*, TSQueryMatch*, uint32_t*)</code><br>
	 * <i>native declaration : line 988</i>
	 */
	byte ts_query_cursor_next_capture(TreeSitterLibrary.TSQueryCursor self, TSQueryMatch match, IntBuffer capture_index);
	/**
	 * Set the maximum start depth for a query cursor.<br>
	 * * This prevents cursors from exploring children nodes at a certain depth.<br>
	 * Note if a pattern includes many children, then they will still be checked.<br>
	 * * The zero max start depth value can be used as a special behavior and<br>
	 * it helps to destructure a subtree by staying on a node and using captures<br>
	 * for interested parts. Note that the zero max start depth only limit a search<br>
	 * depth for a pattern's root node but other nodes that are parts of the pattern<br>
	 * may be searched at any depth what defined by the pattern structure.<br>
	 * * Set to `UINT32_MAX` to remove the maximum start depth.<br>
	 * Original signature : <code>void ts_query_cursor_set_max_start_depth(TSQueryCursor*, uint32_t)</code><br>
	 * <i>native declaration : line 1008</i>
	 */
	void ts_query_cursor_set_max_start_depth(TreeSitterLibrary.TSQueryCursor self, int max_start_depth);
	/**
	 * Get the number of distinct node types in the language.<br>
	 * Original signature : <code>uint32_t ts_language_symbol_count(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1017</i><br>
	 * @deprecated use the safer methods {@link #ts_language_symbol_count(treesitter.TreeSitterLibrary.TSLanguage[])} and {@link #ts_language_symbol_count(treesitter.TreeSitterLibrary.TSLanguage)} instead
	 */
	@Deprecated
	int ts_language_symbol_count(TreeSitterLibrary.TSLanguage self);
	/**
	 * Get the number of distinct node types in the language.<br>
	 * Original signature : <code>uint32_t ts_language_symbol_count(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1017</i>
	 */
	int ts_language_symbol_count(TreeSitterLibrary.TSLanguage self[]);
	/**
	 * Get the number of valid states in this language.<br>
	 * Original signature : <code>uint32_t ts_language_state_count(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1022</i><br>
	 * @deprecated use the safer methods {@link #ts_language_state_count(treesitter.TreeSitterLibrary.TSLanguage[])} and {@link #ts_language_state_count(treesitter.TreeSitterLibrary.TSLanguage)} instead
	 */
	@Deprecated
	int ts_language_state_count(TreeSitterLibrary.TSLanguage self);
	/**
	 * Get the number of valid states in this language.<br>
	 * Original signature : <code>uint32_t ts_language_state_count(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1022</i>
	 */
	int ts_language_state_count(TreeSitterLibrary.TSLanguage self[]);
	/**
	 * Get a node type string for the given numerical id.<br>
	 * Original signature : <code>char* ts_language_symbol_name(const TSLanguage*, TSSymbol)</code><br>
	 * <i>native declaration : line 1027</i><br>
	 * @deprecated use the safer methods {@link #ts_language_symbol_name(treesitter.TreeSitterLibrary.TSLanguage[], short)} and {@link #ts_language_symbol_name(treesitter.TreeSitterLibrary.TSLanguage, short)} instead
	 */
	@Deprecated
	Pointer ts_language_symbol_name(TreeSitterLibrary.TSLanguage self, short symbol);
	/**
	 * Get a node type string for the given numerical id.<br>
	 * Original signature : <code>char* ts_language_symbol_name(const TSLanguage*, TSSymbol)</code><br>
	 * <i>native declaration : line 1027</i>
	 */
	Pointer ts_language_symbol_name(TreeSitterLibrary.TSLanguage self[], short symbol);
	/**
	 * Get the numerical id for the given node type string.<br>
	 * Original signature : <code>TSSymbol ts_language_symbol_for_name(const TSLanguage*, const char*, uint32_t, bool)</code><br>
	 * <i>native declaration : line 1032</i><br>
	 * @deprecated use the safer methods {@link #ts_language_symbol_for_name(treesitter.TreeSitterLibrary.TSLanguage[], java.lang.String, int, byte)} and {@link #ts_language_symbol_for_name(treesitter.TreeSitterLibrary.TSLanguage, com.sun.jna.Pointer, int, byte)} instead
	 */
	@Deprecated
	short ts_language_symbol_for_name(TreeSitterLibrary.TSLanguage self, Pointer string, int length, byte is_named);
	/**
	 * Get the numerical id for the given node type string.<br>
	 * Original signature : <code>TSSymbol ts_language_symbol_for_name(const TSLanguage*, const char*, uint32_t, bool)</code><br>
	 * <i>native declaration : line 1032</i>
	 */
	short ts_language_symbol_for_name(TreeSitterLibrary.TSLanguage self[], String string, int length, byte is_named);
	/**
	 * Get the number of distinct field names in the language.<br>
	 * Original signature : <code>uint32_t ts_language_field_count(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1042</i><br>
	 * @deprecated use the safer methods {@link #ts_language_field_count(treesitter.TreeSitterLibrary.TSLanguage[])} and {@link #ts_language_field_count(treesitter.TreeSitterLibrary.TSLanguage)} instead
	 */
	@Deprecated
	int ts_language_field_count(TreeSitterLibrary.TSLanguage self);
	/**
	 * Get the number of distinct field names in the language.<br>
	 * Original signature : <code>uint32_t ts_language_field_count(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1042</i>
	 */
	int ts_language_field_count(TreeSitterLibrary.TSLanguage self[]);
	/**
	 * Get the field name string for the given numerical id.<br>
	 * Original signature : <code>char* ts_language_field_name_for_id(const TSLanguage*, TSFieldId)</code><br>
	 * <i>native declaration : line 1047</i><br>
	 * @deprecated use the safer methods {@link #ts_language_field_name_for_id(treesitter.TreeSitterLibrary.TSLanguage[], short)} and {@link #ts_language_field_name_for_id(treesitter.TreeSitterLibrary.TSLanguage, short)} instead
	 */
	@Deprecated
	Pointer ts_language_field_name_for_id(TreeSitterLibrary.TSLanguage self, short id);
	/**
	 * Get the field name string for the given numerical id.<br>
	 * Original signature : <code>char* ts_language_field_name_for_id(const TSLanguage*, TSFieldId)</code><br>
	 * <i>native declaration : line 1047</i>
	 */
	Pointer ts_language_field_name_for_id(TreeSitterLibrary.TSLanguage self[], short id);
	/**
	 * Get the numerical id for the given field name string.<br>
	 * Original signature : <code>TSFieldId ts_language_field_id_for_name(const TSLanguage*, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 1052</i><br>
	 * @deprecated use the safer methods {@link #ts_language_field_id_for_name(treesitter.TreeSitterLibrary.TSLanguage[], java.lang.String, int)} and {@link #ts_language_field_id_for_name(treesitter.TreeSitterLibrary.TSLanguage, com.sun.jna.Pointer, int)} instead
	 */
	@Deprecated
	short ts_language_field_id_for_name(TreeSitterLibrary.TSLanguage self, Pointer name, int name_length);
	/**
	 * Get the numerical id for the given field name string.<br>
	 * Original signature : <code>TSFieldId ts_language_field_id_for_name(const TSLanguage*, const char*, uint32_t)</code><br>
	 * <i>native declaration : line 1052</i>
	 */
	short ts_language_field_id_for_name(TreeSitterLibrary.TSLanguage self[], String name, int name_length);
	/**
	 * Check whether the given node type id belongs to named nodes, anonymous nodes,<br>
	 * or a hidden nodes.<br>
	 * * See also [`ts_node_is_named`]. Hidden nodes are never returned from the API.<br>
	 * Original signature : <code>TSSymbolType ts_language_symbol_type(const TSLanguage*, TSSymbol)</code><br>
	 * <i>native declaration : line 1060</i><br>
	 * @deprecated use the safer methods {@link #ts_language_symbol_type(treesitter.TreeSitterLibrary.TSLanguage[], short)} and {@link #ts_language_symbol_type(treesitter.TreeSitterLibrary.TSLanguage, short)} instead
	 */
	@Deprecated
	int ts_language_symbol_type(TreeSitterLibrary.TSLanguage self, short symbol);
	/**
	 * Check whether the given node type id belongs to named nodes, anonymous nodes,<br>
	 * or a hidden nodes.<br>
	 * * See also [`ts_node_is_named`]. Hidden nodes are never returned from the API.<br>
	 * Original signature : <code>TSSymbolType ts_language_symbol_type(const TSLanguage*, TSSymbol)</code><br>
	 * <i>native declaration : line 1060</i>
	 */
	int ts_language_symbol_type(TreeSitterLibrary.TSLanguage self[], short symbol);
	/**
	 * Get the ABI version number for this language. This version number is used<br>
	 * to ensure that languages were generated by a compatible version of<br>
	 * Tree-sitter.<br>
	 * * See also [`ts_parser_set_language`].<br>
	 * Original signature : <code>uint32_t ts_language_version(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1069</i><br>
	 * @deprecated use the safer methods {@link #ts_language_version(treesitter.TreeSitterLibrary.TSLanguage[])} and {@link #ts_language_version(treesitter.TreeSitterLibrary.TSLanguage)} instead
	 */
	@Deprecated
	int ts_language_version(TreeSitterLibrary.TSLanguage self);
	/**
	 * Get the ABI version number for this language. This version number is used<br>
	 * to ensure that languages were generated by a compatible version of<br>
	 * Tree-sitter.<br>
	 * * See also [`ts_parser_set_language`].<br>
	 * Original signature : <code>uint32_t ts_language_version(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1069</i>
	 */
	int ts_language_version(TreeSitterLibrary.TSLanguage self[]);
	/**
	 * Get the next parse state. Combine this with lookahead iterators to generate<br>
	 * completion suggestions or valid symbols in error nodes. Use<br>
	 * [`ts_node_grammar_symbol`] for valid symbols.<br>
	 * Original signature : <code>TSStateId ts_language_next_state(const TSLanguage*, TSStateId, TSSymbol)</code><br>
	 * <i>native declaration : line 1076</i><br>
	 * @deprecated use the safer methods {@link #ts_language_next_state(treesitter.TreeSitterLibrary.TSLanguage[], short, short)} and {@link #ts_language_next_state(treesitter.TreeSitterLibrary.TSLanguage, short, short)} instead
	 */
	@Deprecated
	short ts_language_next_state(TreeSitterLibrary.TSLanguage self, short state, short symbol);
	/**
	 * Get the next parse state. Combine this with lookahead iterators to generate<br>
	 * completion suggestions or valid symbols in error nodes. Use<br>
	 * [`ts_node_grammar_symbol`] for valid symbols.<br>
	 * Original signature : <code>TSStateId ts_language_next_state(const TSLanguage*, TSStateId, TSSymbol)</code><br>
	 * <i>native declaration : line 1076</i>
	 */
	short ts_language_next_state(TreeSitterLibrary.TSLanguage self[], short state, short symbol);
	/**
	 * Create a new lookahead iterator for the given language and parse state.<br>
	 * * This returns `NULL` if state is invalid for the language.<br>
	 * * Repeatedly using [`ts_lookahead_iterator_next`] and<br>
	 * [`ts_lookahead_iterator_current_symbol`] will generate valid symbols in the<br>
	 * given parse state. Newly created lookahead iterators will contain the `ERROR`<br>
	 * symbol.<br>
	 * * Lookahead iterators can be useful to generate suggestions and improve syntax<br>
	 * error diagnostics. To get symbols valid in an ERROR node, use the lookahead<br>
	 * iterator on its first leaf node state. For `MISSING` nodes, a lookahead<br>
	 * iterator created on the previous non-extra leaf node may be appropriate.<br>
	 * Original signature : <code>TSLookaheadIterator* ts_lookahead_iterator_new(const TSLanguage*, TSStateId)</code><br>
	 * <i>native declaration : line 1097</i><br>
	 * @deprecated use the safer methods {@link #ts_lookahead_iterator_new(treesitter.TreeSitterLibrary.TSLanguage[], short)} and {@link #ts_lookahead_iterator_new(treesitter.TreeSitterLibrary.TSLanguage, short)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSLookaheadIterator ts_lookahead_iterator_new(TreeSitterLibrary.TSLanguage self, short state);
	/**
	 * Create a new lookahead iterator for the given language and parse state.<br>
	 * * This returns `NULL` if state is invalid for the language.<br>
	 * * Repeatedly using [`ts_lookahead_iterator_next`] and<br>
	 * [`ts_lookahead_iterator_current_symbol`] will generate valid symbols in the<br>
	 * given parse state. Newly created lookahead iterators will contain the `ERROR`<br>
	 * symbol.<br>
	 * * Lookahead iterators can be useful to generate suggestions and improve syntax<br>
	 * error diagnostics. To get symbols valid in an ERROR node, use the lookahead<br>
	 * iterator on its first leaf node state. For `MISSING` nodes, a lookahead<br>
	 * iterator created on the previous non-extra leaf node may be appropriate.<br>
	 * Original signature : <code>TSLookaheadIterator* ts_lookahead_iterator_new(const TSLanguage*, TSStateId)</code><br>
	 * <i>native declaration : line 1097</i>
	 */
	TreeSitterLibrary.TSLookaheadIterator ts_lookahead_iterator_new(TreeSitterLibrary.TSLanguage self[], short state);
	/**
	 * Delete a lookahead iterator freeing all the memory used.<br>
	 * Original signature : <code>void ts_lookahead_iterator_delete(TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1102</i>
	 */
	void ts_lookahead_iterator_delete(TreeSitterLibrary.TSLookaheadIterator self);
	/**
	 * Reset the lookahead iterator to another state.<br>
	 * * This returns `true` if the iterator was reset to the given state and `false`<br>
	 * otherwise.<br>
	 * Original signature : <code>bool ts_lookahead_iterator_reset_state(TSLookaheadIterator*, TSStateId)</code><br>
	 * <i>native declaration : line 1110</i>
	 */
	byte ts_lookahead_iterator_reset_state(TreeSitterLibrary.TSLookaheadIterator self, short state);
	/**
	 * Reset the lookahead iterator.<br>
	 * * This returns `true` if the language was set successfully and `false`<br>
	 * otherwise.<br>
	 * Original signature : <code>bool ts_lookahead_iterator_reset(TSLookaheadIterator*, const TSLanguage*, TSStateId)</code><br>
	 * <i>native declaration : line 1118</i><br>
	 * @deprecated use the safer methods {@link #ts_lookahead_iterator_reset(treesitter.TreeSitterLibrary.TSLookaheadIterator, treesitter.TreeSitterLibrary.TSLanguage[], short)} and {@link #ts_lookahead_iterator_reset(treesitter.TreeSitterLibrary.TSLookaheadIterator, treesitter.TreeSitterLibrary.TSLanguage, short)} instead
	 */
	@Deprecated
	byte ts_lookahead_iterator_reset(TreeSitterLibrary.TSLookaheadIterator self, TreeSitterLibrary.TSLanguage language, short state);
	/**
	 * Reset the lookahead iterator.<br>
	 * * This returns `true` if the language was set successfully and `false`<br>
	 * otherwise.<br>
	 * Original signature : <code>bool ts_lookahead_iterator_reset(TSLookaheadIterator*, const TSLanguage*, TSStateId)</code><br>
	 * <i>native declaration : line 1118</i>
	 */
	byte ts_lookahead_iterator_reset(TreeSitterLibrary.TSLookaheadIterator self, TreeSitterLibrary.TSLanguage language[], short state);
	/**
	 * Get the current language of the lookahead iterator.<br>
	 * Original signature : <code>TSLanguage* ts_lookahead_iterator_language(const TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1123</i><br>
	 * @deprecated use the safer methods {@link #ts_lookahead_iterator_language(treesitter.TreeSitterLibrary.TSLookaheadIterator[])} and {@link #ts_lookahead_iterator_language(treesitter.TreeSitterLibrary.TSLookaheadIterator)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSLanguage ts_lookahead_iterator_language(TreeSitterLibrary.TSLookaheadIterator self);
	/**
	 * Get the current language of the lookahead iterator.<br>
	 * Original signature : <code>TSLanguage* ts_lookahead_iterator_language(const TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1123</i>
	 */
	TreeSitterLibrary.TSLanguage ts_lookahead_iterator_language(TreeSitterLibrary.TSLookaheadIterator self[]);
	/**
	 * Advance the lookahead iterator to the next symbol.<br>
	 * * This returns `true` if there is a new symbol and `false` otherwise.<br>
	 * Original signature : <code>bool ts_lookahead_iterator_next(TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1130</i>
	 */
	byte ts_lookahead_iterator_next(TreeSitterLibrary.TSLookaheadIterator self);
	/**
	 * Get the current symbol of the lookahead iterator;<br>
	 * Original signature : <code>TSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1135</i><br>
	 * @deprecated use the safer methods {@link #ts_lookahead_iterator_current_symbol(treesitter.TreeSitterLibrary.TSLookaheadIterator[])} and {@link #ts_lookahead_iterator_current_symbol(treesitter.TreeSitterLibrary.TSLookaheadIterator)} instead
	 */
	@Deprecated
	short ts_lookahead_iterator_current_symbol(TreeSitterLibrary.TSLookaheadIterator self);
	/**
	 * Get the current symbol of the lookahead iterator;<br>
	 * Original signature : <code>TSSymbol ts_lookahead_iterator_current_symbol(const TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1135</i>
	 */
	short ts_lookahead_iterator_current_symbol(TreeSitterLibrary.TSLookaheadIterator self[]);
	/**
	 * Get the current symbol type of the lookahead iterator as a null terminated<br>
	 * string.<br>
	 * Original signature : <code>char* ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1141</i><br>
	 * @deprecated use the safer methods {@link #ts_lookahead_iterator_current_symbol_name(treesitter.TreeSitterLibrary.TSLookaheadIterator[])} and {@link #ts_lookahead_iterator_current_symbol_name(treesitter.TreeSitterLibrary.TSLookaheadIterator)} instead
	 */
	@Deprecated
	Pointer ts_lookahead_iterator_current_symbol_name(TreeSitterLibrary.TSLookaheadIterator self);
	/**
	 * Get the current symbol type of the lookahead iterator as a null terminated<br>
	 * string.<br>
	 * Original signature : <code>char* ts_lookahead_iterator_current_symbol_name(const TSLookaheadIterator*)</code><br>
	 * <i>native declaration : line 1141</i>
	 */
	Pointer ts_lookahead_iterator_current_symbol_name(TreeSitterLibrary.TSLookaheadIterator self[]);
	/**
	 * Create a Wasm store.<br>
	 * Original signature : <code>TSWasmStore* ts_wasm_store_new(TSWasmEngine*, TSWasmError*)</code><br>
	 * <i>native declaration : line 1166</i><br>
	 * @deprecated use the safer method {@link #ts_wasm_store_new(com.sun.jna.ptr.PointerByReference, treesitter.TSWasmError)} instead
	 */
	@Deprecated
	PointerByReference ts_wasm_store_new(Pointer engine, TSWasmError error);
	/**
	 * Create a Wasm store.<br>
	 * Original signature : <code>TSWasmStore* ts_wasm_store_new(TSWasmEngine*, TSWasmError*)</code><br>
	 * <i>native declaration : line 1166</i>
	 */
	PointerByReference ts_wasm_store_new(PointerByReference engine, TSWasmError error);
	/**
	 * Free the memory associated with the given Wasm store.<br>
	 * Original signature : <code>void ts_wasm_store_delete(TSWasmStore*)</code><br>
	 * <i>native declaration : line 1174</i><br>
	 * @deprecated use the safer method {@link #ts_wasm_store_delete(com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated
	void ts_wasm_store_delete(Pointer TSWasmStorePtr1);
	/**
	 * Free the memory associated with the given Wasm store.<br>
	 * Original signature : <code>void ts_wasm_store_delete(TSWasmStore*)</code><br>
	 * <i>native declaration : line 1174</i>
	 */
	void ts_wasm_store_delete(PointerByReference TSWasmStorePtr1);
	/**
	 * Create a language from a buffer of Wasm. The resulting language behaves<br>
	 * like any other Tree-sitter language, except that in order to use it with<br>
	 * a parser, that parser must have a Wasm store. Note that the language<br>
	 * can be used with any Wasm store, it doesn't need to be the same store that<br>
	 * was used to originally load it.<br>
	 * Original signature : <code>TSLanguage* ts_wasm_store_load_language(TSWasmStore*, const char*, const char*, uint32_t, TSWasmError*)</code><br>
	 * <i>native declaration : line 1183</i><br>
	 * @deprecated use the safer methods {@link #ts_wasm_store_load_language(com.sun.jna.ptr.PointerByReference, java.lang.String, java.lang.String, int, treesitter.TSWasmError)} and {@link #ts_wasm_store_load_language(com.sun.jna.ptr.PointerByReference, com.sun.jna.Pointer, com.sun.jna.Pointer, int, treesitter.TSWasmError)} instead
	 */
	@Deprecated
	TreeSitterLibrary.TSLanguage ts_wasm_store_load_language(Pointer TSWasmStorePtr1, Pointer name, Pointer wasm, int wasm_len, TSWasmError error);
	/**
	 * Create a language from a buffer of Wasm. The resulting language behaves<br>
	 * like any other Tree-sitter language, except that in order to use it with<br>
	 * a parser, that parser must have a Wasm store. Note that the language<br>
	 * can be used with any Wasm store, it doesn't need to be the same store that<br>
	 * was used to originally load it.<br>
	 * Original signature : <code>TSLanguage* ts_wasm_store_load_language(TSWasmStore*, const char*, const char*, uint32_t, TSWasmError*)</code><br>
	 * <i>native declaration : line 1183</i>
	 */
	TreeSitterLibrary.TSLanguage ts_wasm_store_load_language(PointerByReference TSWasmStorePtr1, String name, String wasm, int wasm_len, TSWasmError error);
	/**
	 * Create a language from a buffer of Wasm. The resulting language behaves<br>
	 * like any other Tree-sitter language, except that in order to use it with<br>
	 * a parser, that parser must have a Wasm store. Note that the language<br>
	 * can be used with any Wasm store, it doesn't need to be the same store that<br>
	 * was used to originally load it.<br>
	 * Original signature : <code>TSLanguage* ts_wasm_store_load_language(TSWasmStore*, const char*, const char*, uint32_t, TSWasmError*)</code><br>
	 * <i>native declaration : line 1183</i>
	 */
	TreeSitterLibrary.TSLanguage ts_wasm_store_load_language(PointerByReference TSWasmStorePtr1, Pointer name, Pointer wasm, int wasm_len, TSWasmError error);
	/**
	 * Check if the language came from a Wasm module. If so, then in order to use<br>
	 * this langauge with a Parser, that parser must have a Wasm store assigned.<br>
	 * Original signature : <code>bool ts_language_is_wasm(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1195</i><br>
	 * @deprecated use the safer methods {@link #ts_language_is_wasm(treesitter.TreeSitterLibrary.TSLanguage[])} and {@link #ts_language_is_wasm(treesitter.TreeSitterLibrary.TSLanguage)} instead
	 */
	@Deprecated
	byte ts_language_is_wasm(TreeSitterLibrary.TSLanguage TSLanguagePtr1);
	/**
	 * Check if the language came from a Wasm module. If so, then in order to use<br>
	 * this langauge with a Parser, that parser must have a Wasm store assigned.<br>
	 * Original signature : <code>bool ts_language_is_wasm(const TSLanguage*)</code><br>
	 * <i>native declaration : line 1195</i>
	 */
	byte ts_language_is_wasm(TreeSitterLibrary.TSLanguage TSLanguagePtr1[]);
	/**
	 * Assign the given Wasm store to the parser. A parser must have a Wasm store<br>
	 * in order to use Wasm languages.<br>
	 * Original signature : <code>void ts_parser_set_wasm_store(TSParser*, TSWasmStore*)</code><br>
	 * <i>native declaration : line 1201</i><br>
	 * @deprecated use the safer method {@link #ts_parser_set_wasm_store(treesitter.TreeSitterLibrary.TSParser, com.sun.jna.ptr.PointerByReference)} instead
	 */
	@Deprecated
	void ts_parser_set_wasm_store(TreeSitterLibrary.TSParser TSParserPtr1, Pointer TSWasmStorePtr1);
	/**
	 * Assign the given Wasm store to the parser. A parser must have a Wasm store<br>
	 * in order to use Wasm languages.<br>
	 * Original signature : <code>void ts_parser_set_wasm_store(TSParser*, TSWasmStore*)</code><br>
	 * <i>native declaration : line 1201</i>
	 */
	void ts_parser_set_wasm_store(TreeSitterLibrary.TSParser TSParserPtr1, PointerByReference TSWasmStorePtr1);
	/**
	 * Remove the parser's current Wasm store and return it. This returns NULL if<br>
	 * the parser doesn't have a Wasm store.<br>
	 * Original signature : <code>TSWasmStore* ts_parser_take_wasm_store(TSParser*)</code><br>
	 * <i>native declaration : line 1207</i>
	 */
	PointerByReference ts_parser_take_wasm_store(TreeSitterLibrary.TSParser TSParserPtr1);
	/**
	 * Set the allocation functions used by the library.<br>
	 * * By default, Tree-sitter uses the standard libc allocation functions,<br>
	 * but aborts the process when an allocation fails. This function lets<br>
	 * you supply alternative allocation functions at runtime.<br>
	 * * If you pass `NULL` for any parameter, Tree-sitter will switch back to<br>
	 * its default implementation of that function.<br>
	 * * If you call this function after the library has already been used, then<br>
	 * you must ensure that either:<br>
	 *  1. All the existing objects have been freed.<br>
	 *  2. The new allocator shares its state with the old one, so it is capable<br>
	 *     of freeing memory that was allocated by the old allocator.<br>
	 * Original signature : <code>void ts_set_allocator(ts_set_allocator_new_malloc_callback*, ts_set_allocator_new_calloc_callback*, ts_set_allocator_new_realloc_callback*, ts_set_allocator_new_free_callback*)</code><br>
	 * <i>native declaration : line 1229</i>
	 */
	void ts_set_allocator(TreeSitterLibrary.ts_set_allocator_new_malloc_callback new_malloc, TreeSitterLibrary.ts_set_allocator_new_calloc_callback new_calloc, TreeSitterLibrary.ts_set_allocator_new_realloc_callback new_realloc, TreeSitterLibrary.ts_set_allocator_new_free_callback new_free);
	public static class TSQuery extends PointerType {
		public TSQuery(Pointer address) {
			super(address);
		}
		public TSQuery() {
			super();
		}
	};
	public static class TSLanguage extends PointerType {
		public TSLanguage(Pointer address) {
			super(address);
		}
		public TSLanguage() {
			super();
		}
	};
	public static class TSParser extends PointerType {
		public TSParser(Pointer address) {
			super(address);
		}
		public TSParser() {
			super();
		}
	};
	public static class TSQueryCursor extends PointerType {
		public TSQueryCursor(Pointer address) {
			super(address);
		}
		public TSQueryCursor() {
			super();
		}
	};
	public static class TSLookaheadIterator extends PointerType {
		public TSLookaheadIterator(Pointer address) {
			super(address);
		}
		public TSLookaheadIterator() {
			super();
		}
	};
	public static class TSWasmEngine extends PointerType {
		public TSWasmEngine(Pointer address) {
			super(address);
		}
		public TSWasmEngine() {
			super();
		}
	};
	public static class TSWasmStore extends PointerType {
		public TSWasmStore(Pointer address) {
			super(address);
		}
		public TSWasmStore() {
			super();
		}
	};
	public static class TSTree extends PointerType {
		public TSTree(Pointer address) {
			super(address);
		}
		public TSTree() {
			super();
		}
	};

	// additional
	TSLanguage tree_sitter_zenscript();
	void free_memory(Pointer pointer);
}
